{"version":"1","records":[{"hierarchy":{"lvl1":"アニメーション動画の作成"},"type":"lvl1","url":"/animation","position":0},{"hierarchy":{"lvl1":"アニメーション動画の作成"},"content":"","type":"content","url":"/animation","position":1},{"hierarchy":{"lvl1":"アニメーション動画の作成","lvl2":"連番画像の作成"},"type":"lvl2","url":"/animation#id","position":2},{"hierarchy":{"lvl1":"アニメーション動画の作成","lvl2":"連番画像の作成"},"content":"\n\n連番の画像を作ることで，それらを結合した動画を作成することができます．本家GMTではシェルスクリプトによるループを自力で作成するほか，gmt movie という\n\nモジュール があります．PyGMTへのgmt movieモジュールの移植はv0.17.0時点でまだ実現していないようでが，Pythonのループを使えば，簡単に連番画像を作成することができます．\n\nここでは，1枚の画像を作る関数を for ループでパラメタを変えながら実行して画像保存する方法を一例として紹介します．\n\nimport pygmt\nimport numpy as np\nimport os\nimport tempfile\n\nまず，画像の作成です．ここでは簡単な三角関数のグラフを，波が伝播しているかのように横に平行移動させていくことにしましょう．\n\ndef plot_fig(phi):\n    \n    \"\"\" 初期位相 `phi` の sin カーブを描画する．\"\"\"\n\n    x = np.linspace(0, 5, 201)\n    y = np.sin(2*np.pi*x + phi)\n    \n    fig = pygmt.Figure()\n    \n    fig.plot(region = [0, 5, -1.1, 1.1], projection = 'X10c/4c', \n             x = x, y = y, \n             pen = 'thick,200/110/30', frame = ['WS', 'xaf', 'yaf'])\n\n    return fig\n\nこれを単独で実行すると，以下のようになります．plot_fig()関数はPyGMTのfigオブジェクトを返すため，.show()メソッドにより画像を表示させています．\n\nplot_fig(0.0).show() #  0.0の場合\n\nplot_fig(np.pi/2).show() # π/2の場合\n\nたしかに引数の初期位相を変えるとグラフが平行移動している様子がわかります．\nそれでは，これをループにして少しずつ初期位相を変えつつ，連番のファイルにしていきます．\n\n動画化には ffmpeg というツールを使います．このツールで連番ファイルから動画を作る際には，連番の桁数を揃えなければなりません．\n\n# 初期位相のリスト\nphi0 = np.arange(0, 2*np.pi, 2*np.pi/200)\n\n# 画像保存先の一時ディレクトリ作成\ntmpdir = tempfile.mkdtemp()\n\n# enumerateを使って，初期位相の値＋0からの連番を取り出す．\nfor i, phi in enumerate(phi0):\n    \n    f = plot_fig(phi) #画像プロット\n\n    # f文字列を使って連番を3桁整数の文字列に\n    figname = f'plot_{i:03d}.png' \n    f.savefig(os.path.join(tmpdir, figname))\n\n説明はほぼコメントに書いてあるとおりですが，まず画像を動かすパラメタである初期位相のリストを作り，また同時に画像保存先の一時ディレクトリを作成しておきます．手動でディレクトリ名を指定してもよいのですが，ここではtmpfile.mkdtemp()関数を使いました．この関数は，乱数を使った名前の適当なディレクトリを作成し，そのディレクトリ名を返します．確認してみましょう．\n\nprint(tmpdir)\n\n! ls $tmpdir\n\nたしかにディレクトリが作られ，その中に画像が200枚作られています．\n\nNote\n\nmkdtemp()が返すディレクトリの場所は，Pythonやそれを動かすOSによって異なります．自分で設定することもできます．\n\n","type":"content","url":"/animation#id","position":3},{"hierarchy":{"lvl1":"アニメーション動画の作成","lvl2":"動画への変換"},"type":"lvl2","url":"/animation#id-1","position":4},{"hierarchy":{"lvl1":"アニメーション動画の作成","lvl2":"動画への変換"},"content":"\n\n作成された画像から動画を作成するには，コマンドラインから ffmpegを使います．ここでは gif アニメーションとmp4 形式の動画を作成してみましょう．\n\n","type":"content","url":"/animation#id-1","position":5},{"hierarchy":{"lvl1":"アニメーション動画の作成","lvl3":"gifアニメーション","lvl2":"動画への変換"},"type":"lvl3","url":"/animation#gif","position":6},{"hierarchy":{"lvl1":"アニメーション動画の作成","lvl3":"gifアニメーション","lvl2":"動画への変換"},"content":"\n\n%%bash -s \"$tmpdir\" \nffmpeg -i \"$1/plot_%3d.png\" \\\n  -vf \"scale=800:-1,split [a][b];[a] palettegen [p];[b][p] paletteuse\" \\\n  -y out.gif \\\n  > /dev/null 2>&1 \n\nここでは，いくつかのテクニックを使っています．\n\nまず，Jupyter Notebookの cell magic で，%%bashを Pythonセルの最初に記載しておくと，そのセル内は bashのコマンドとして実行される，という機能を使っています．そこに -s オプションで，Pythonの tmpdir 変数を \"$tmpdir\" として与えました．すると，あたかもこの変数の中身（一時ディレクトリの名前）が，シェルスクリプトの実行時第一引数のように扱われます．つまり，$1 というシェル変数で利用できるのです．\n\nNote\n\nそんな面倒なことをするくらいならUnixコマンドラインで直接ffmpegを実行する，というやりかたもあるでしょう．\n\nffmpeg は -i オプションで入力ファイルを，コマンドラインの最後に出力ファイル名を書きます．動画形式は出力ファイル名の拡張子からある程度判断されます．その直前にある-yは，出力ファイルがすでにあるときに確認をせずに上書きするためのオプションです．Jupyter Notebook上でbashコマンドを扱うときには，対話的な実行は難しいようなので，このオプションを使っています．\n\n入力と出力の間にある -vf からなる行は，出力される画像サイズを指定（scale=800:-1 で横幅を800pxにしつつ縦横比を維持）するほか，256色しか使えないgifアニメーションを綺麗に出力するためのカラーパレットという機能を用いています．\n\n最終行はffmpegからの標準エラー出力が大量に出てくるため，それらを捨てるリダイレクションです．\n\nこの結果，以下のような動画が作成できました．ちょうどループするように調整して作成したので，延々と波が動いているように見えます．\n\n\n\nGif animationとして作成された連番アニメーション動画\n\n","type":"content","url":"/animation#gif","position":7},{"hierarchy":{"lvl1":"アニメーション動画の作成","lvl3":"Mpeg-4 Movie","lvl2":"動画への変換"},"type":"lvl3","url":"/animation#mpeg-4-movie","position":8},{"hierarchy":{"lvl1":"アニメーション動画の作成","lvl3":"Mpeg-4 Movie","lvl2":"動画への変換"},"content":"\n\n一方，mp4形式の動画を作成するには，たとえば以下のようにします．\n\n%%bash -s \"$tmpdir\" \nffmpeg -i \"$1/plot_%3d.png\" \\\n  -vf scale=800:328 \\\n  -qscale:v 1 \\\n  -pix_fmt yuv420p \\\n  -y out.mp4 \\\n  > /dev/null 2>&1\n\nすると，以下のような動画が作成されるはずです．mp4の場合には-qscale:v 1 オプションを付けておくと，クオリティを劣化させずに動画にできます（昔の -qscale 0 オプションに相当します）．\n\n\n\nMP4 movieとして作成された連番アニメーション動画\n\nTip\n\nここでは，tempdirは作成しっぱなしで，その中身のファイルは削除されません．実際には，このようにシステムの一時ディレクトリ置き場に作られたものは，OSのシステムによって一定期間経つと自動的に削除されるようです．\n\n","type":"content","url":"/animation#mpeg-4-movie","position":9},{"hierarchy":{"lvl1":"アニメーション動画の作成","lvl2":"大量の画像の効率的な生成"},"type":"lvl2","url":"/animation#id-2","position":10},{"hierarchy":{"lvl1":"アニメーション動画の作成","lvl2":"大量の画像の効率的な生成"},"content":"\n\nアニメーションを作成するためには，すこしずつ違ったパラメタを用いた大量の画像を作る必要があります．これまでの例ではJupyter Notebookで対話的に実行できる例を紹介してきましたが，図を1枚ずつ作成するのにはどうしても時間がかかります．たとえば，前述の200枚の連番画像を生成するのに，筆者の環境では約140秒かかりました．凝った図のアニメーションを作成しようとすると，図の生成にかかる時間は飛躍的に伸びてしまいます．\n\nそこで，異なる番号の画像を作成するPyGMTプロセスを複数個並列に実行することで，より高速に大量の画像を生成する方法を考えます．\n\nPytnonには，マルチスレッドで複数の関数を並列に実行するconcurrentやthreadingといったモジュールもあります．しかし，筆者の環境で試したところ，単一のPythonカーネル内でこれらのライブラリを用いてPyGMTの互いに異なる画像を並列に生成することはできない（文法的に問題なさそうでも実行時エラーが生じる）ようでした．そこで，1枚の画像を生成するPythonスクリプトを，シェル（bashなど）コマンドを組み合わせることにより複数並列に実行する方針を採ることにします．\n\nまずは，そのためのPythonスクリプトを作成します．作成済みの plot_fig() 関数をそのまま使って，以下のようなスクリプトファイル exe_plot_fig.py にします．import sys\nimport os\nimport pygmt\nimport numpy as np\n\n\ndef plot_fig(phi):\n    \n    \"\"\" 初期位相 `phi` の sin カーブを描画する．\"\"\"\n\n    x = np.linspace(0, 5, 201)\n    y = np.sin(2*np.pi*x + phi)\n    \n    fig = pygmt.Figure()\n    \n    fig.plot(region = [0, 5, -1.1, 1.1], projection = 'X10c/4c', \n             x = x, y = y, \n             pen = 'thick,200/110/30', frame = ['WS', 'xaf', 'yaf'])\n\n    return fig\n\n\nif __name__ == \"__main__\": # スクリプトとして実行したときにはこの行以下が実行される\n    \n    # コマンドライン引数\n    dir_out = sys.argv[1]\n    i = int(sys.argv[2])\n    \n    # 引数 i -> 角度 phi\n    nmax = 200\n    phi = 2 * np.pi * i / nmax\n    \n    # 画像生成\n    f = plot_fig(phi)\n\n    # 画像保存\n    figname = f'plot_{i:03d}.png' \n    f.savefig(os.path.join(dir_out, figname))\n\nこれは，Jupyter上で画像を作成して保存したこととほとんど同じことを実行するスクリプトです．違いとしては，sys.argv[] リストを用いて，スクリプト実行時の引数（スクリプト名のあとに空白区切りで記載）で保存先のディレクトリと画像の番号を取得し，その番号1枚の画像だけを作成します．たとえば，python ./exe_plot_fig.py . 3\n\nというコマンドをシェルで実行するか，あるいはJupyter上でなら%%bash\npython ./exe_plot_fig.py . 3\n\nとすることで，カレントディレクトリ（.）にplot_003.pngが作成されます．これを踏まえて，以下のように xargs コマンドを用いてスクリプトを並列実行します．\n\n%%bash\ntmpdir=$(mktemp -d)\necho ${tmpdir}\nseq 0 199 | xargs -P10 -n1 python ./exe_plot_fig.py ${tmpdir}\n\n最初の2行は画像作成用の一時ディレクトリの作成とその表示です．最終行は2つのコマンドに分かれていて，まず seq コマンドにより 0 1 2 ... 199 の連番を生成し，それをパイプ | を通じて xargs に渡します．xargsコマンドは，標準入力から受け取ったものを，それ以降にかかれているコマンドに「適当な数ずつ」渡す，というものです．ここでは，オプション -n1 を指定することで，デフォルトでは自動で判断される受け渡しの数を1つに限定しています．すなわち，seqで生成した連番が1つずつ exe_plot_fig.py に渡されるという仕組みです．さらに，xargsのオプション-P10で，xargsで指定されたコマンドを複数（この場合は10個）ずつ並列に実行させています．自動生成した${tmpdir}を見ていると，10枚ずつほぼ同時に画像が生成されていくことが確認できるでしょう．ここでは省略していますが，同じセルのなかでffmpegまで実行して動画を作ってしまうとよりよいでしょう．\n\n類似の方法としては，以下のようなbashのシェルスクリプトを用いてpythonスクリプトを並列に実行する方法もあります．#!/bin/bash\n\ntmpdir=$(mktemp -d)\n\n(( j = 0 ))\nfor i in $(seq 0 199)\ndo\n    ./exe_plot_fig.py ${tmpdir} ${i} &\n    (( j ++ ))\n    \n    if (( j == 10 )); then\n        (( j = 0 ))\n        wait\n    fi\ndone\n\n一つ一つの可視化スクリプトをバックグラウンド（&）で実行させつつ，別の変数 $j をカウンタとして利用して，一定個数のスクリプトがバックグラウンドで実行されたら wait によりすべてのスクリプトの実行が終了するのを待つ，という方針です．\n\n比較すると，xargsのほうが圧倒的に簡単で，並列数の制御もしやすいと思います．ただし，xargsはそれに続くコマンドの最後の引数に標準入力を与えること，seqコマンドと組み合わせるなら，可視化スクリプトが整数値を受け取って，それをパラメタとして画像を生成するように書く必要があることには注意が必要です．\n\nほかには，ここでは扱いませんが，データファイル1つに対して画像ファイル1枚が対応している場合には，makefileを書くことによって並列にスクリプトを実行することもできます．PyGMTの例ではありませんが，詳しい解説がたとえば\n\nここにあります．","type":"content","url":"/animation#id-2","position":11},{"hierarchy":{"lvl1":"PyGMTの基本"},"type":"lvl1","url":"/basic-map","position":0},{"hierarchy":{"lvl1":"PyGMTの基本"},"content":"ここでは，簡単な地図の作成を通じてPyGMTの使い方の基本を学びます．\n\n","type":"content","url":"/basic-map","position":1},{"hierarchy":{"lvl1":"PyGMTの基本","lvl2":"準備"},"type":"lvl2","url":"/basic-map#id","position":2},{"hierarchy":{"lvl1":"PyGMTの基本","lvl2":"準備"},"content":"\n\n","type":"content","url":"/basic-map#id","position":3},{"hierarchy":{"lvl1":"PyGMTの基本","lvl3":"Jupyter Notebookの立ち上げ","lvl2":"準備"},"type":"lvl3","url":"/basic-map#jupyter-notebook","position":4},{"hierarchy":{"lvl1":"PyGMTの基本","lvl3":"Jupyter Notebookの立ち上げ","lvl2":"準備"},"content":"\n\n本節以降では，Jupyter NotebookでインタラクティブにPyGMTを実行していくことにします．そこで，（minicondaによるインストールの場合は仮想環境をactivateしたのちに）端末からjupyter notebook\n\nによりJupyter Notebookを起動します．すると自動的に既定のブラウザが立ち上がります．別のブラウザウィンドウからも，\n\nhttp://​localhost:8888 にアクセスするとJupyterにアクセスができるはずです．\nこの記事もそうしてJupyter Notebook上で作成しています．\n\nCaution\n\nもしJupyter Notebookを複数立ち上げていると，接続のためのポート番号が 8888 から変わることがあります．詳しくはJupyter Notebookの起動時メッセージに記載されているはずです．\n\nTip\n\n別の方法として，VSCodeで .ipynb 拡張子のファイルを作成する方法もあります．\n\nVSCodeはMicrosoftにより開発されているテキストエディタですが，Pythonプログラミングのための公式拡張機能を導入すれば，Jupyter Notebook形式を直接編集でき，かつminicondaで作成した仮想環境をカーネルとして選択してノートブック内のPythonスクリプトを実行することができます．\n\n","type":"content","url":"/basic-map#jupyter-notebook","position":5},{"hierarchy":{"lvl1":"PyGMTの基本","lvl3":"モジュールのimport","lvl2":"準備"},"type":"lvl3","url":"/basic-map#id-import","position":6},{"hierarchy":{"lvl1":"PyGMTの基本","lvl3":"モジュールのimport","lvl2":"準備"},"content":"\n\nPyGMTを使うためには，まず import します．\n\nimport pygmt\n\nこれで，pygmt.XXX という形でPyGMT内のオブジェクトを呼び出せるようになりました．\n\nまた，画像の保存場所として fig ディレクトリを作成しておきましょう．Jupyter Notebookでは行の先頭に ! をつけるか，あるいはセルの1行目に %%bash と書くことでシェルコマンドを実行できます．\n\n%%bash\n# fig ディレクトリが存在しなければ作成する\nif [ ! -d fig ]; then\n  mkdir fig\nfi\n\nPyGMTは活発な更新がなされているため，このページに含まれているサンプルコードも，バージョンによっては修正が必要であったり，警告がでたりします．自分の使っているPyGMTのバージョンを確認するには，以下のようにします．\n\nprint(pygmt.__version__)\n\nそのほか，pygmt.show_versions() という関数では，関連ライブラリのバージョンやその格納状況まで詳しい情報が得られます．\n\n","type":"content","url":"/basic-map#id-import","position":7},{"hierarchy":{"lvl1":"PyGMTの基本","lvl2":"PyGMTによる作図の基本"},"type":"lvl2","url":"/basic-map#pygmt","position":8},{"hierarchy":{"lvl1":"PyGMTの基本","lvl2":"PyGMTによる作図の基本"},"content":"\n\npygmtでは，まずfig = pygmt.Figure()\n\nで図のオブジェクトを作成し，GMTのコマンドに相当するfig.XXXXX()\n\nを重ねていくことで作図していきます．最後にfig.show()\n\nとすればJupyter Notebook上に表示されますし，fig.savefig(filename)\n\nとするとfilenameの拡張子に応じて画像ファイルとして保存できます．もうすこし融通の効く（その代わりにやや複雑な）画像保存の方法は \n\nこちら で説明します．\n\n","type":"content","url":"/basic-map#pygmt","position":9},{"hierarchy":{"lvl1":"PyGMTの基本","lvl2":"基本の地図"},"type":"lvl2","url":"/basic-map#id-1","position":10},{"hierarchy":{"lvl1":"PyGMTの基本","lvl2":"基本の地図"},"content":"まずは単純な，従来のGMTでの gmt pscoast コマンドに相当する地図を作図してみましょう．各オプションの意味はコード内コメントを参照してください．\n\nfig = pygmt.Figure()\n\nfig.coast(\n    projection  = 'N138/12c',                         # 投影法とサイズ．メルカトルなら 'M12c' など．\n    region      = (128, 146, 30, 46),                 # 領域は西端・東端・南端・北端の順にリストかタプルで与える．\n    shorelines  = 'default,black',                    # 海岸線のペンの設定（後述）\n    area_thresh = 100,                                # 細かい領域の描画下限 (km^2) 値を大きくすると小さな島が消える\n    resolution  = 'f',                                # 'c', 'l', 'i', 'h', 'f' の順に高くなる\n    land        = '249/243/202',                      # 陸地の色を 0-255の値の R/G/B で指定\n    water       = '190/220/250',                      # 水の色を 0-255の値の R/G/B で指定\n    map_scale   = '142.5/32/32/400',                  # 距離スケールの水平・縦位置と距離サイズ\n    frame       = ['WSen+tFigure', 'xafg', 'yafg']    # 南西に軸名・タイトル指定（+t) およびXY方向それぞれの軸情報\n)\n\nfig.show()\nfig.savefig('fig/pygmt-coastline.png')\n\n","type":"content","url":"/basic-map#id-1","position":11},{"hierarchy":{"lvl1":"PyGMTの基本","lvl3":"Jupyter Notebookにおける画像の表示","lvl2":"基本の地図"},"type":"lvl3","url":"/basic-map#jupyter-notebook-1","position":12},{"hierarchy":{"lvl1":"PyGMTの基本","lvl3":"Jupyter Notebookにおける画像の表示","lvl2":"基本の地図"},"content":"\n\n結果をJupyter Notebook内で見るだけならば fig.show()を指定します．画像として保存するなら fig.savefig ですが，pngのほか pdfなども指定可能です．また，show=Trueオプションをつけると，その環境で標準のビューワ（\n\nたとえばmacOSならPreview​.app）が起動します．\n\nまた，fig.show() に width=オプションで数字を指定すると，表示される図の大きさを指定できます．\n\n","type":"content","url":"/basic-map#jupyter-notebook-1","position":13},{"hierarchy":{"lvl1":"PyGMTの基本","lvl3":"投影法","lvl2":"基本の地図"},"type":"lvl3","url":"/basic-map#id-2","position":14},{"hierarchy":{"lvl1":"PyGMTの基本","lvl3":"投影法","lvl2":"基本の地図"},"content":"fig.coastのprojectionオプションで地図投影法を指定しています．ここではロビソン図法（-JN）を用いています．この図法では，中心線の経度（138）と図の横幅の大きさ（12c）を指定する必要があります．投影法の特徴により，図の縦の大きさは描画範囲と横幅から自動的に決まります．\n\nよく使われるメルカトル図法の場合は中心の経度は必要なく，たとえば -JM12c のように指定します．この場合も縦方向の大きさは指定できません．\n\nGMTには多種多様な投影法が用意されていますが，ここではその網羅的な説明はしません．必要に応じて他解説や公式マニュアルを参照してください．\n\n","type":"content","url":"/basic-map#id-2","position":15},{"hierarchy":{"lvl1":"PyGMTの基本","lvl3":"ペンと色","lvl2":"基本の地図"},"type":"lvl3","url":"/basic-map#id-3","position":16},{"hierarchy":{"lvl1":"PyGMTの基本","lvl3":"ペンと色","lvl2":"基本の地図"},"content":"GMTにおける線の描画は\n\n太さ (太さの名前あるいは数値）\n\n色 （色名 あるいは RGB）\n\nパターン（パターン名あるいは数値）\n\nの3つの情報を , で組み合わせます．上記のスクリプトの場合は太さが default，色が black を組み合わせています．パターンは実線・破線・点線などですが，省略したことでデフォルトの実線が選ばれています．\n\n太さの選択肢には faint, default, thinnest, thinner, thin, thick, thicker, thickest, fat, fatter, fattest があります．左ほど細いです．色名は主な名前は使えるようです．パターンはdotted, dashed, solidのほか，たとえば..だと点線，--だと破線，-.-だと一点鎖線のような指定もできます．\n\n色は名前のほか，光の三原色 Red(R), Green(G), Blue(B)の大きさを0-255までの数値で表して，R/G/B で表現することもできます．\n\n","type":"content","url":"/basic-map#id-3","position":17},{"hierarchy":{"lvl1":"PyGMTの基本","lvl3":"地図描画 Tips: resolution と area_thresh","lvl2":"基本の地図"},"type":"lvl3","url":"/basic-map#id-tips-resolution-area-thresh","position":18},{"hierarchy":{"lvl1":"PyGMTの基本","lvl3":"地図描画 Tips: resolution と area_thresh","lvl2":"基本の地図"},"content":"海岸線の解像度は5種類ありますが，粗すぎても細かすぎても綺麗な図になりません．大は小を兼ねると思うかもしれませんが，細かすぎると微細な地形の特徴まで描画されるため，細かな島やリアス式海岸などでごちゃごちゃした印象になりがちです．解像度だけを変えた図を以下に示します．\n\nfig = pygmt.Figure()\n\nfig.shift_origin(3, 25)\n\nfig.coast(\n    projection  = 'N138/8c',                          \n    region      = (128, 146, 30, 46),                 \n    shorelines  = 'default,black',                    \n    resolution  = 'f',                                \n    land        = '249/243/202',                      \n    water       = '190/220/250',                      \n    map_scale   = '142.5/32/32/400',                  \n    frame       = ['WSen+tresolution = f', 'xafg', 'yafg'] \n)\n\nfig.shift_origin(10, 0)\nfig.coast(\n    projection  = 'N138/8c',                          \n    region      = (128, 146, 30, 46),                 \n    shorelines  = 'default,black',                    \n    resolution  = 'h',                                \n    land        = '249/243/202',                      \n    water       = '190/220/250',                      \n    map_scale   = '142.5/32/32/400',                  \n    frame       = ['WSen+tresolution = h', 'xafg', 'yafg']\n)\n\nfig.shift_origin(-10, -11)\nfig.coast(\n    projection  = 'N138/8c',                          \n    region      = (128, 146, 30, 46),                 \n    shorelines  = 'default,black',                    \n    resolution  = 'i',                                \n    land        = '249/243/202',                      \n    water       = '190/220/250',                      \n    map_scale   = '142.5/32/32/400',                  \n    frame       = ['WSen+tresolution = i', 'xafg', 'yafg']\n)\n\nfig.shift_origin(10, 0)\nfig.coast(\n    projection  = 'N138/8c',                          \n    region      = (128, 146, 30, 46),                 \n    shorelines  = 'default,black',                    \n    resolution  = 'l',                                \n    land        = '249/243/202',                      \n    water       = '190/220/250',                      \n    map_scale   = '142.5/32/32/400',                  \n    frame       = ['WSen+tresolution = l', 'xafg', 'yafg']\n)\n\nfig.show()\n\n高解像度ほどよいかというと，特に瀬戸内海などは小さな島がたくさん描画されて，真っ黒になってしまっています．そこで活躍するのが area_thresh オプションです．このオプションを指定すると，数値で与えられた面積（km^2）以下のサイズのものが描画されなくなります．そこで，海岸線の解像度は高めにしつつ，area_threshを適宜設定すると綺麗な海岸線が描画できます．いくつかarea_threshの数値を変えた例を示しましょう．\n\nfig = pygmt.Figure()\n\nfig.shift_origin(3, 25)\n\nfig.coast(\n    projection  = 'N138/8c',                         \n    region      = (128, 146, 30, 46),                 \n    shorelines  = 'default,black',                    \n    resolution  = 'f',  \n    land        = '249/243/202',                      \n    water       = '190/220/250',                      \n    map_scale   = '142.5/32/32/400',                  \n    area_thresh = 0, \n    frame       = ['WSen+tarea_thresh=0', 'xafg', 'yafg']\n)\n\nfig.shift_origin(10, 0)\nfig.coast(\n    projection  = 'N138/8c',                          # 投影法とサイズ．メルカトルなら 'M12c' など．\n    region      = (128, 146, 30, 46),                 # 領域はリストかタプルで与える．\n    shorelines  = 'default,black',                    # 海岸線のペンの設定．\n    resolution  = 'h',                                # 'c', 'l', 'i', 'h', 'f' の順に高くなる\n    land        = '249/243/202',                      # 陸地の色を 0-255の値の R/G/B で指定\n    water       = '190/220/250',                      # 水の色を 0-255の値の R/G/B で指定\n    map_scale   = '142.5/32/32/400',                  # 距離スケールの水平・縦位置と距離サイズ\n    area_thresh = 100, \n    frame       = ['WSen+tarea_thresh=100', 'xafg', 'yafg']\n)\n\nfig.shift_origin(-10, -11)\nfig.coast(\n    projection  = 'N138/8c',                          # 投影法とサイズ．メルカトルなら 'M12c' など．\n    region      = (128, 146, 30, 46),                 # 領域はリストかタプルで与える．\n    shorelines  = 'default,black',                    # 海岸線のペンの設定．\n    resolution  = 'i',                                # 'c', 'l', 'i', 'h', 'f' の順に高くなる\n    land        = '249/243/202',                      # 陸地の色を 0-255の値の R/G/B で指定\n    water       = '190/220/250',                      # 水の色を 0-255の値の R/G/B で指定\n    map_scale   = '142.5/32/32/400',                  # 距離スケールの水平・縦位置と距離サイズ\n    area_thresh = 10000, \n    frame       = ['WSen+tarea_thresh=10000', 'xafg', 'yafg']\n\n)\n\nfig.shift_origin(10, 0)\nfig.coast(\n    projection  = 'N138/8c',                          # 投影法とサイズ．メルカトルなら 'M12c' など．\n    region      = (128, 146, 30, 46),                 # 領域はリストかタプルで与える．\n    shorelines  = 'default,black',                    # 海岸線のペンの設定．\n    resolution  = 'l',                                # 'c', 'l', 'i', 'h', 'f' の順に高くなる\n    land        = '249/243/202',                      # 陸地の色を 0-255の値の R/G/B で指定\n    water       = '190/220/250',                      # 水の色を 0-255の値の R/G/B で指定\n    map_scale   = '142.5/32/32/400',                  # 距離スケールの水平・縦位置と距離サイズ\n    area_thresh = 100000, \n    frame       = ['WSen+tarea_thresh=100000', 'xafg', 'yafg']\n\n)\n\nfig.show()\n\n後半は明らかにやりすぎですね．\n日本列島全体を表示するなら，area_thresh=100程度がほどよいように思います．もっと細かな地域を表示する場合は，適宜area_threshの値を小さくするとよいでしょう．\n\n","type":"content","url":"/basic-map#id-tips-resolution-area-thresh","position":19},{"hierarchy":{"lvl1":"PyGMTの基本","lvl3":"basemap とパラメタの省略","lvl2":"基本の地図"},"type":"lvl3","url":"/basic-map#basemap","position":20},{"hierarchy":{"lvl1":"PyGMTの基本","lvl3":"basemap とパラメタの省略","lvl2":"基本の地図"},"content":"\n\n上記の例では fig.coast ひとつですべてを描画しましたが，軸の描画を fig.basemap に任せることもできます：\n\nfig = pygmt.Figure()\n\n\nfig.coast(\n    projection  = 'N138/12c',          \n    region      = (128, 146, 30, 46),  \n    shorelines  = 'default,black',     \n    area_thresh = 100,                 \n    resolution  = 'f',                 \n    land        = '249/243/202', \n    water       = '190/220/250', \n    map_scale   = '142.5/32/32/400',   \n)\n\nfig.basemap(\n    frame       = ['WSen+tFigure', 'xafg', 'yafg'] \n)\n\nfig.show()\n\n上記の例では，fig.basemap のオプションは frame しかないことに注目してください．\n\n必須と思える projection や region といったオプションは，その前の fig.coast で用いられた値が自動的に引き継がれています．\n\n","type":"content","url":"/basic-map#basemap","position":21},{"hierarchy":{"lvl1":"PyGMTの基本","lvl3":"エイリアス","lvl2":"基本の地図"},"type":"lvl3","url":"/basic-map#id-4","position":22},{"hierarchy":{"lvl1":"PyGMTの基本","lvl3":"エイリアス","lvl2":"基本の地図"},"content":"PyGMTでは，従来のGMTと比べてオプションの意味が多くの人にとってわかりやすい名前がつけられてる一方，従来オプション名のエイリアスも設定されています．たとえば先程の地図は，以下のようなエイリアスオプション名を用いて作成することもできます．初めて見る人には全く意味不明のオプションでしょうが，GMTに馴染みのある人にはむしろ使いやすいかもしれません．fig = pygmt.Figure()\n\nfig.coast(\n    J = 'N138/12c',                        \n    R = '128/146/30/46',                \n    W = 'default,black',                   \n    A = 100,                               \n    D = 'f',                               \n    G = '249/243/202',                     \n    S = '190/220/250',                     \n    L = '142.5/32/32/400',                 \n    B = ['WSen+tFigure', 'xafg', 'yafg'] \n)\n\nオプション名のエイリアスなので当然ですが，結果として得られる画像は全く同じです．ただし，Short-form parameter (A) is not recommended. \nUse long-form parameter 'area_thresh' instead.\n\nのような警告がたくさん出てきます．\n\n従来のGMTユーザーは，この警告を逆手にとって，まず自分の知っている short-form オプションでpygmtを動かしてみて，\nそこで表示される SyntaxWarning を見て現代的な long-form parameter 名を調べるようにすると，ドキュメントを引く手間が省けてよいかもしれません．\n\nさらに進んだ応用としては，公式には実装，ドキュメント化されていない機能の利用 があります．PyGMTの公式マニュアルを読んでいると，GMTの各モジュールに対して，必ずしもすべてのオプションが実装，ドキュメント化されているわけではないことがありますしかし，そのような場合でもshort-formオプションをつかうと「動いてしまう」ことがしばしばあるよう．もちろんこれは自己責任での利用になりますし，今後PyGMTの開発が進むことで減っていくことでしょう．\n\n","type":"content","url":"/basic-map#id-4","position":23},{"hierarchy":{"lvl1":"PyGMTの基本","lvl2":"従来型のGMTスクリプトとの比較"},"type":"lvl2","url":"/basic-map#id-gmt","position":24},{"hierarchy":{"lvl1":"PyGMTの基本","lvl2":"従来型のGMTスクリプトとの比較"},"content":"\n\nこれまでに紹介した PyGMTのスクリプトと，それらと（ほとんど）同じ図を出力するbashによる従来型のGMTスクリプトを比較してみます．以下のタブをクリックするとコードが表示されます．なお，比較しやすいようできるだけ改行を多めに書いています．\n\nfig = pygmt.Figure()\n\nfig.coast(\n    projection  = 'N138/12c',\n    region      = (128, 146, 30, 46),\n    shorelines  = 'default,black',\n    area_thresh = 100,\n    resolution  = 'f',\n    land        = '230/240/220',\n    water       = '220/235/250',\n    map_scale   = '142.5/32/32/400',\n    frame       = ['WSen+tFigure', 'xafg', 'yafg']\n)\n\nfig = pygmt.Figure()\n\nfig.coast(\n    J = 'N138/12c',                        \n    R = (128, 146, 30, 46),                \n    W = 'default,black',                   \n    A = 100,                               \n    D = 'f',                               \n    G = '230/240/220',                     \n    S = '220/235/250',                     \n    L = '142.5/32/32/400',                 \n    B = ['WSen+tFigure', 'xafg', 'yafg'] \n)\n\n#!/bin/bash\n\n# 海岸線と枠を描画\ngmt pscoast -JN138/12c \\\n            -R128/146/30/46 \\\n            -Wdefault,black \\\n            -A100 \\\n            -Df \\\n            -G230/240/220 \\\n            -S220/235/250 \\\n            -L142.5/32/32/400 \\\n            -BWSen+t\"Figure\" -Bxafg -Byafg \\\n> fig/classic-coastline.ps\n\n# Postscript画像をPNGに変換\ngmt psconvert -Tg -A -P -Qg2 -Qt2 fig/classic-coastline.ps\n\n# 不要な中間生成物であるPostscriptを削除\nrm -f fig/classic-coastline.ps\n\n#!/bin/bash\n\n# modern mode では gmt begin ~ end の間でコマンド実行．\ngmt begin fig/modern-coastline png\n\n    gmt coast \\\n        -JN138/12c \\\n        -R128/146/30/46 \\\n        -Wdefault,black \\\n        -A100 \\\n        -Df \\\n        -G230/240/220 \\\n        -S220/235/250 \\\n        -L142.5/32/32/400 \\\n        -BWSen+t\"Figure\" -Bxafg -Byafg \n        \ngmt end\n\nこのような単一のコマンドからなるスクリプトではあまり差が大きくありませんが，コードの可読性は一番左のpygmt original がもっとも高いでしょう．また，PyGMTとGMT6 modern modeでは複数のGMTコマンドを用いる図においてミスを犯しやすい -O と -K オプションが不要であったり，現代では直接用いることはあまりない（と思われる）Postscriptファイルから他形式に変換する手間が省けています．","type":"content","url":"/basic-map#id-gmt","position":25},{"hierarchy":{"lvl1":"GMTの微調整"},"type":"lvl1","url":"/config","position":0},{"hierarchy":{"lvl1":"GMTの微調整"},"content":"GMTは gmt defaults コマンドでさまざまな調整を行うことができます．PyGMTでも同じことを実現するpygmt.configがあります．\n\nしかし，（シェルスクリプトによる従来のGMTでもそうなのですが）うかつに設定を変えると，同じスクリプト（シェルの場合は同じディレクトリ）で作成する他の図にも意図せず影響を及ぼしてしまうことがあります．\n\nそこで，PyGMTではPythonのwith構文を用いる方法が提案されています．以下の例は全く同じ図をconfigだけを変えてプロットしたものです．\n\nimport pygmt\n\nfig = pygmt.Figure()\n\n\nfig.coast(\n    projection  = 'M12c',                       \n    region      =  (139.8, 141.6, 40.5, 41.7),  \n    shorelines  = 'default,black',              \n    area_thresh = 10,                           \n    resolution  = 'f',                          \n    land        = '230/240/220',                \n    water       = '220/235/250',                \n    map_scale   = '141.25/41.6/41.6/20',        \n    frame       = ['WSen+tWithout Config', 'xafg', 'yafg']\n)\n\nfig.shift_origin(xshift = 15)\n\nwith pygmt.config(\n    FONT_ANNOT_PRIMARY   = '12p,Helvetica,black',\n    FONT_ANNOT_SECONDARY = '11p,Helvetica,black',\n    FONT_LABEL           = '14p,Helvetica,black',\n    FONT_TITLE           = '16p,Helvetica,black',\n    MAP_GRID_PEN_PRIMARY = '0.25p,30/30/30,.',\n    MAP_FRAME_TYPE       = 'plain',\n    FORMAT_GEO_MAP       = 'DF',\n    FORMAT_FLOAT_OUT     = '%.1f',\n    PS_IMAGE_COMPRESS    = 'none',\n    PS_LINE_CAP          = 'round',\n    PS_LINE_JOIN         = 'round'\n):\n\n    fig.coast(\n        projection  = 'M12c',                      \n        region      = (139.8, 141.6, 40.5, 41.7),  \n        shorelines  = 'default,black',             \n        area_thresh = 10,                          \n        resolution  = 'f',                         \n        land        = '230/240/220',               \n        water       = '220/235/250',               \n        map_scale   = '141.25/41.6/41.6/20',       \n        frame       = ['WSen+tWith Config', 'xafg', 'yafg']\n    )\n\n\nfig.show()\n\nまったく同じ領域の地図を（タイトル以外）全く同じオプションでプロットしていますが，緯度経度の書式（時分秒か度か），それに伴い自動で設定されるラベルの間隔，フレームの種類，ラベルやタイトルのフォントやフォントサイズなどが異なっていることがわかるでしょう．\n\nWarning\n\n上記の地図のプロット順を逆にする（withでオプションありを先に描画）実験をしてみたところ，\nほとんどはうまく行くのですが，グリッド線の線種（点線）だけはconfigなしの図にも反映されてしまいました．\nもしかしたらこれはバグかもしれません．\n\n(2025-11-29追記) \n\nバグとして認知されている ようです．","type":"content","url":"/config","position":1},{"hierarchy":{"lvl1":"軸の設定"},"type":"lvl1","url":"/frame","position":0},{"hierarchy":{"lvl1":"軸の設定"},"content":"frame オプションは柔軟性が高く，さまざまな表現ができます．ここではそれを実例をもとに紹介します．\n\n","type":"content","url":"/frame","position":1},{"hierarchy":{"lvl1":"軸の設定","lvl2":"frame 設定の基本"},"type":"lvl2","url":"/frame#frame","position":2},{"hierarchy":{"lvl1":"軸の設定","lvl2":"frame 設定の基本"},"content":"\n\nframe オプションは3つの要素を取るリストあるいはタプルとして，frame = [ '(direction)', 'x(option-for-axis)', 'y(option-for-axis)']\n\nという形式で指定します．\n\n(direction) は東西南北（左右上下）の軸を描画するかどうかの設定です．大文字 WSEN であれば軸名（ラベル）・annotation（数値等）・ティックマークを表示し，小文字 wsen であれば軸とティックマークのみを表示します．また，(direction) に +t(title) とするとグラフ上部にタイトル文字 (title) を表示します．\n\nx軸とy軸のオプション (option-for-axis) には，以下の3つの主要要素があります．\n\na: 軸の数値を表示する間隔を指定します．Major tickmark （ティックマークのうち長いほう）も数値と同時に表示されます．\n\nf: Minor tickmark （ティックマークのうち短い方）の間隔を指定します．\n\ng: グラフ内にグリッドを引く間隔を指定します．\n\nこれらの記号の後には間隔の数値が入ります．たとえば x軸に20ごとに数値を打ち，10ごとにminor tickmark, 10ごとにグリッドラインを引きたいのであれば， 'xa20f10g10' と指定します．\nただし，数値は省略できます．省略された場合にはGMTが region の上下限から適当に判断します．\n\nいくつかの例を示しておきます．\n\nimport pygmt\nimport numpy as np\n\nfig = pygmt.Figure()\nfig.basemap(projection='X12c/12c', region=[0, 100, 0, 20], \n            frame = ['WSEN', 'xafg', 'yafg'])\nfig.savefig('fig/WSEN1.png', crop=0.5)\n\nfig = pygmt.Figure()\nfig.basemap(projection='X12c/12c', region=[0, 100, 0, 20], \n            frame = ['WSen', 'xafg', 'yafg'])\nfig.savefig('fig/WSEN2.png', crop=0.5)\n\nfig = pygmt.Figure()\nfig.basemap(projection='X12c/12c', region=[0, 100, 0, 20], \n            frame = ['wsEN', 'xafg', 'yafg'])\nfig.savefig('fig/WSEN3.png', crop=0.5)\n\nfig = pygmt.Figure()\nfig.basemap(projection='X12c/12c', region=[0, 100, 0, 20], \n            frame = ['WS', 'xafg', 'yafg'])\nfig.savefig('fig/WSEN4.png', crop=0.5)\n\nimport pygmt\nfig = pygmt.Figure()\nfig.basemap(projection='X12c/12c', region=[0, 100, 0, 20], \n            frame = ['WS', 'xafg', 'yafg'])\n\nimport pygmt\nfig = pygmt.Figure()\nfig.basemap(projection='X12c/12c', region=[0, 100, 0, 20], \n            frame = ['WSen', 'xafg', 'yafg'])\n\nimport pygmt\nfig = pygmt.Figure()\nfig.basemap(projection='X12c/12c', region=[0, 100, 0, 20], \n            frame = ['wsEN', 'xafg', 'yafg'])\n\nimport pygmt\nfig = pygmt.Figure()\nfig.basemap(projection='X12c/12c', region=[0, 100, 0, 20], \n            frame = ['WS', 'xafg', 'yafg'])\n\nfig = pygmt.Figure()\nfig.basemap(projection='X12c/12c', region=[0, 100, 0, 20], \n            frame = ['WS', 'xaf', 'yaf'])\nfig.savefig('fig/afg1.png', crop=0.5)\n\nfig = pygmt.Figure()\nfig.basemap(projection='X12c/12c', region=[0, 100, 0, 20], \n            frame = ['WS', 'xa', 'ya'])\nfig.savefig('fig/afg2.png', crop=0.5)\n\nfig = pygmt.Figure()\nfig.basemap(projection='X12c/12c', region=[0, 100, 0, 20], \n            frame = ['WS'])\nfig.savefig('fig/afg3.png', crop=0.5)\n\nimport pygmt\nfig = pygmt.Figure()\nfig.basemap(projection='X12c/12c', region=[0, 100, 0, 20], \n            frame = ['WS', 'xafg', 'yafg'])\n\nimport pygmt\nfig = pygmt.Figure()\nfig.basemap(projection='X12c/12c', region=[0, 100, 0, 20], \n            frame = ['WS', 'xaf', 'yaf'])\n\nimport pygmt\nfig = pygmt.Figure()\nfig.basemap(projection='X12c/12c', region=[0, 100, 0, 20], \n            frame = ['WS', 'xa', 'ya'])\n\nimport pygmt\nfig = pygmt.Figure()\nfig.basemap(projection='X12c/12c', region=[0, 100, 0, 20], \n            frame = ['WS', 'x', 'y'])\n\n","type":"content","url":"/frame#frame","position":3},{"hierarchy":{"lvl1":"軸の設定","lvl3":"軸のオプション","lvl2":"frame 設定の基本"},"type":"lvl3","url":"/frame#id","position":4},{"hierarchy":{"lvl1":"軸の設定","lvl3":"軸のオプション","lvl2":"frame 設定の基本"},"content":"a, f, g の設定の後に + 記号と以下のフラグを追加することで，軸をカスタマイズすることができます．\n\n+l<label> 軸ラベルの追加．a が表示される軸方向に文字列 <label> が表示されます．\n\n+p<prefix> a の前に文字列がつきます．\n\n+u<unit> 単位文字列の追加．a の数値に単位がつきます．\n\n+a<angle> 軸の文字列を <angle> だけ回転させます\n\nすべてのオプションを有効にした例を示します．\n\nfig = pygmt.Figure()\nfig.basemap(projection='X12c/12c', region = [0, 100, 0, 20], \n            frame = ['S', 'xa20f10+lSpeed+pc=+u km/s+a-30'])\nfig.show(crop=0.5)\n\nTip\n\n機能の例ということで紹介しましたが，実際にこのようにグラフを描くことは（すくなくとも筆者の専門の地震学界隈では）あまりない，と思います．数値に変数名や単位をつけるかわりにラベルに単位を付けるほうが一般的でしょう．\n\n","type":"content","url":"/frame#id","position":5},{"hierarchy":{"lvl1":"軸の設定","lvl2":"Primary and secondary axes"},"type":"lvl2","url":"/frame#primary-and-secondary-axes","position":6},{"hierarchy":{"lvl1":"軸の設定","lvl2":"Primary and secondary axes"},"content":"\n\n軸オプションの x, y 軸名の前に p あるいは s を付すことで，軸を primary と secondary の2つに分けて描画することができます．primaryのほうが座標軸に近い部分に小さなフォントで，secondaryのほうが離れて大きなフォントで，それぞれ表示されます．ラベルはsecondaryのものしか表示されません．\n\n以下の例は，primaryを20ごとに，secondaryを100ごとに表示したものです．+l オプションはあえて両方につけていますが，primaryのほうは表示されていないことが確認できるでしょう．\n\nfig = pygmt.Figure()\nfig.basemap(projection='X12c/12c', region = [0, 200, 0, 20], \n            frame = ['S', 'pxa20f10+lPrimary', 'sxa100f50+lSecondary'])\nfig.show(crop=0.5)\n\nあえてprimaryとsecondaryの役割を逆転させてみると以下のような軸になります．あまり有用ではなさそうです．\n\nfig = pygmt.Figure()\nfig.basemap(projection='X12c/12c', region = [0, 200, 0, 20], \n            frame = ['S', 'sxa20f10+lSecondary', 'pxa100f50+lPecondary'])\nfig.show(crop=0.5)\n\n","type":"content","url":"/frame#primary-and-secondary-axes","position":7},{"hierarchy":{"lvl1":"軸の設定","lvl2":"時間軸の扱い"},"type":"lvl2","url":"/frame#id-1","position":8},{"hierarchy":{"lvl1":"軸の設定","lvl2":"時間軸の扱い"},"content":"（執筆中予定です．次回更新までお待ちください）\n\n","type":"content","url":"/frame#id-1","position":9},{"hierarchy":{"lvl1":"軸の設定","lvl2":"カスタム軸"},"type":"lvl2","url":"/frame#id-2","position":10},{"hierarchy":{"lvl1":"軸の設定","lvl2":"カスタム軸"},"content":"\n\nPyGMTのマニュアルには直接は書かれていませんが，本家GMTには \n\ncustom axes（カスタム軸）というより柔軟に軸情報を設定できる機能が解説されていて，それがそのままPyGMTでも使えます．\n\nカスタム軸は，任意の位置にtickや数値を配置でき，それらは等間隔である必要もありません．x軸，y軸それぞれに対して軸情報を記載したファイルを作成し，それを frame の軸情報に c オプションで呼び出します．少々煩雑なので，具体例から紹介します．\n\nx = np.linspace(0, 2*np.pi, 201)\ny = np.sin(x)\n\nfig = pygmt.Figure()\n\nfn_x = 'xannots.txt'\nfn_y = 'yannots.txt'\n\nwith open(fn_x, 'w') as f: \n    print(f\"0         a  0\", file=f)\n    print(f\"{  np.pi/4:8.6f}  f         \", file=f)\n    print(f\"{  np.pi/2:8.6f} ag  @~p@~/2\", file=f)\n    print(f\"{3*np.pi/4:8.6f}  f         \", file=f)\n    print(f\"{  np.pi  :8.6f} ag  @~p@~  \", file=f)\n    print(f\"{5*np.pi/4:8.6f}  f         \", file=f)\n    print(f\"{3*np.pi/2:8.6f} ag 3@~p@~/2\", file=f)\n    print(f\"{7*np.pi/4:8.6f}  f         \", file=f)\n    print(f\"{2*np.pi  :8.6f} ag 2@~p@~  \", file=f)\n\nwith open(fn_y, 'w') as f:\n    print(\"-1 ig Negative\", file=f)\n    print(\" 0 ig Positive\", file=f)\n    print(\" 1 ig\", file=f)\n\nfig.plot(projection='X12c/6c', \n         region = [0, 2*np.pi, -1.1, 1.1], \n         x = x, y = y, \n         pen = 'thickest,200/100/100@40', \n         frame = ['WSen', f'xc{fn_x}', \n                  'pya1f0.5g1', f'syc{fn_y}'])\n\nfig.show(crop=0.5)\n\nこのグラフでは，x 軸では \\pi / 2 ごとに annotation （しかも数値ではなく \\pi を用いて）を表示しています．y軸はsecondary axisにの数値ではなく範囲の中央（ここでは -1から0と0から1の間）に Positive, Negativeの文字列を配置しました．これらはラベルではなくてannotation (軸情報の afgのaに相当）で実現されています．\n\nこのような軸を実現しているのが，スクリプト中盤で作成しているファイル xannots.txt yannots.txt です．これらのファイルが軸情報で 'xc(x軸ファイル名)', 'yc(y軸ファイル名)' の形式で呼び出されています．\n\nまずはxannots.txtから見てみましょう．0         a  0\n0.785398  f         \n1.570796 ag  @~p@~/2\n2.356194  f         \n3.141593 ag  @~p@~  \n3.926991  f         \n4.712389 ag 3@~p@~/2\n5.497787  f         \n6.283185 ag 2@~p@~\n\nこのファイルは1列目に軸情報をプロットする位置，2列目に a, f, g の組み合わせ，そして2列目に a が含まれる場合には3列めに annotationとして表示する文字列，がそれぞれ書かれています．文字列部分では，ギリシャ文字を表示するGMT記号 @~ を用いて，アルファベット p に相当する \\pi を表示させています．-1 ig Negative\n 0 ig Positive\n 1 ig\n\n一方，yannots では2列目にグリッド線を表す g のほかに i が使われています．これは interval annotation という記法で，指定された数値の位置の真下ではなく，次の行の値との中間に3列目の文字列を描画する，というものです．時間軸の月名や年の表示にしばしば使われている記法と同じです．interval annotaionでは，「次」の値がないと中間の位置が定まりませんから，3行目には3列目の文字列がない行を付与しています．1列目の数値（1）があってはじめて2行目に指定された Positive の表示される位置が定まる，というわけです．\n\nTip\n\nカスタム軸は情報をファイルで渡す必要があり，そのままですとあとで不要なファイルが残されてしまいます．そこで以下のように tempfile モジュールで一時ディレクトリを作成し，それを with ブロックで表記すれば，ブロックから抜けた時点でディレクトリごとファイルが削除されます．これなら必要な図だけが残り，スマートです．import tempfile\nimport os\n\nfig = pygmt.Figure()\n\n# 一時ディレクトリを作成\nwith tempfile.TemporaryDirectory() as tmpdir: \n\n    # 軸情報ファイルは一時ディレクトリの下に作成する\n    with open(os.path.join(tmpdir, \"xannots.txt\"), \"w\") as fpx: \n        print(f\"0         a  0\", file=fpx)\n        print(f\"{  np.pi/4:8.6f}  f         \", file=fpx)\n        print(f\"{  np.pi/2:8.6f} ag  @~p@~/2\", file=fpx)\n        print(f\"{3*np.pi/4:8.6f}  f         \", file=fpx)\n        print(f\"{  np.pi  :8.6f} ag  @~p@~  \", file=fpx)\n        print(f\"{5*np.pi/4:8.6f}  f         \", file=fpx)\n        print(f\"{3*np.pi/2:8.6f} ag 3@~p@~/2\", file=fpx)\n        print(f\"{7*np.pi/4:8.6f}  f         \", file=fpx)\n        print(f\"{2*np.pi  :8.6f} ag 2@~p@~  \", file=fpx)\n\n    with open(os.path.join(tmpdir, \"yaanots.txt\"), \"w\") as fpy:\n        print(\"-1 ig Negative\", file=fpy)\n        print(\"0 ig Positive\",  file=fpy)\n        print(\"1 ig\",           file=fpy)\n\n    # ファイル名はファイルオブジェクト fp に対して fp.name で参照できる．\n    # ファイルを閉じたあとでも（変数を上書きしていない限り）大丈夫．\n    fig.plot(projection='X12c/6c', \n             region = [0, 2*np.pi, -1.1, 1.1], \n             x = x, y = y, \n             pen = 'thickest,200/100/100@40', \n             frame = ['WSen', f'xc{fpx.name}', \n                      'pya1f0.5g1', f'syc{fpy.name}'])","type":"content","url":"/frame#id-2","position":11},{"hierarchy":{"lvl1":"地図上への情報描画"},"type":"lvl1","url":"/inf-on-map","position":0},{"hierarchy":{"lvl1":"地図上への情報描画"},"content":"","type":"content","url":"/inf-on-map","position":1},{"hierarchy":{"lvl1":"地図上への情報描画","lvl2":"データの準備"},"type":"lvl2","url":"/inf-on-map#id","position":2},{"hierarchy":{"lvl1":"地図上への情報描画","lvl2":"データの準備"},"content":"pygmtが用意しているexampleデータに日本列島周辺の地震情報がありますので，それを題材にしてプロットしてみましょう．\n\nimport pygmt\n\nhypdata = pygmt.datasets.load_sample_data(name='japan_quakes')\n\n上記コマンドはデモンストレーション用のデータセットの読み込みの専用コマンドです．オンラインからデータを読み込むので多少時間がかかります．\n\nWarning\n\nこのコマンドは PyGMT v0.5.0 まではhypdata = pygmt.datasets.load_japan_quakes()\n\nでした．\n\n震源情報は，pandasのデータフレームとして変数 data に格納されます．ただしここではpandasの細かい利用法を意識する必要はありません．printしてみると，ほどよく途中を省略してデータフレームの概略を表示してくれます．\n\nprint(hypdata)\n\nPandasのデータフレームは表形式で複数の列が名前付きで含まれていることがわかるでしょう．このなかから特定の列のデータを取り出すには，たとえばdata.year\n\nのように 変数名.列名 とします．\n\n","type":"content","url":"/inf-on-map#id","position":3},{"hierarchy":{"lvl1":"地図上への情報描画","lvl3":"固定サイズ単一色のプロット","lvl2":"データの準備"},"type":"lvl3","url":"/inf-on-map#id-1","position":4},{"hierarchy":{"lvl1":"地図上への情報描画","lvl3":"固定サイズ単一色のプロット","lvl2":"データの準備"},"content":"まずは単純シンボルプロットから行いましょう．\nfig.plot で x軸（経度方向）とy軸（緯度方向）のデータ配列を個別に指定します．\n\ngrid_data = pygmt.datasets.load_earth_relief(\n    resolution='01m',\n    region = [128, 150, 28, 50]\n)\ngradient_data = pygmt.grdgradient(\n    grid      = grid_data,\n    azimuth   = [45, 135], \n    normalize = 'e0.7'\n)\n\nfig = pygmt.Figure()\n\nfig.basemap(\n    region     = [128, 146, 30, 46],\n    projection = 'M15c', \n    frame      = ['WSen+tSeismicity around Japanese Archipelago', 'xaf', 'yaf'],\n)\n\nfig.grdimage(\n    region   = [128, 146, 30, 46], \n    grid     = grid_data, \n    shading  = gradient_data,\n    cmap     = 'gray'                   # 地震のほうを目立たせるため地形はモノクロに\n)\n\nfig.coast(\n    shorelines  = 'thinner,black@40', \n    area_thresh = '100', \n    resolution  = 'h',\n    water       = '30@70'               # 海域をすこし暗くする\n)\n\n# 震央分布のプロット\nfig.plot(\n    x            = hypdata.longitude,   # 横軸データ\n    y            = hypdata.latitude,    # 縦軸データ\n    fill         = 'orange',            # 塗りつぶし色の指定\n    style        = 'c0.3c',             # 固定サイズの場合は (symbol)(size) 指定\n    pen          = 'thinner,black',     # 縁取りのペン\n    transparency = 40                   # コマンド全体に影響する透明度設定\n)\n\nfig.show()\n\nこの図では，tranparency オプションでプロットするデータの透明度を指定しています．数値が100に近いほど透明に近くなっていきます．tranparencyオプションの代わりに，色名やRGB値にcolor = 'red@60'\n\nのように指定する方法もあります．この方法だと，たとえば塗りつぶしの色は半透明にするものの，penオプションで指定する縁取りの線は不透明にする，というようなことも実現できます．\n\nWarning\n\ntransparency オプションを frame を指定しているコマンドに付与すると，図の枠やラベルが半透明になってしまいます．半透明オプションの使い所には注意が必要です．\n\nWarning\n\n地形段彩図の描画ページでも紹介しましたが，最新のPyGMTでは plot 関数の色の塗りつぶしオプションが color から fill に変更となりました．\n\n","type":"content","url":"/inf-on-map#id-1","position":5},{"hierarchy":{"lvl1":"地図上への情報描画","lvl3":"可変サイズ・可変色プロット","lvl2":"データの準備"},"type":"lvl3","url":"/inf-on-map#id-2","position":6},{"hierarchy":{"lvl1":"地図上への情報描画","lvl3":"可変サイズ・可変色プロット","lvl2":"データの準備"},"content":"次に，マグニチュードと深さを用いてシンボルの色と大きさを変化させてみましょう．\n\nfig = pygmt.Figure()\n\nfig.basemap(\n    region     = [128, 146, 30, 46],\n    projection = 'M15c', \n    frame      = ['WSen+tSeismicity around Japanese Archipelago', 'xaf', 'yaf'],\n)\n\nfig.grdimage(\n    region     = [128, 146, 30, 46], \n    grid       = grid_data, \n    shading    = gradient_data,\n    cmap = 'gray'\n)\n\nfig.coast(\n    shorelines  = 'thinner,black@40', \n    area_thresh = '100', \n    resolution  = 'h',\n    water       = '30@70'\n)\n\npygmt.makecpt(\n    cmap         = 'seis',        # カラーマップを選択\n    series       = [0, 700, 50],  # min/max/increment\n    background   = True,          # 値の上限・下限超過データの色を上限値・下限値と等しくする\n    continuous   = True, \n    transparency = 40    \n)\n\nfig.plot(\n    x     = hypdata.longitude,\n    y     = hypdata.latitude,\n    style = 'c',         \n    pen   = 'thinner,black', \n    size  = 0.05 + 0.01 * (2**hypdata.magnitude),  # サイズ指定（cm）    \n    cmap  = True,                                  # カラーマップ利用\n    fill  = hypdata.depth_km,                      # 深さデータに基づき色を判断\n)\n\nfig.colorbar(\n    position = '+e',\n    frame    = ['x+lDepth [km]'], \n)\n\n\nfig.show()\n\n","type":"content","url":"/inf-on-map#id-2","position":7},{"hierarchy":{"lvl1":"地図上への情報描画","lvl3":"カラーパレットの扱い","lvl2":"データの準備"},"type":"lvl3","url":"/inf-on-map#id-3","position":8},{"hierarchy":{"lvl1":"地図上への情報描画","lvl3":"カラーパレットの扱い","lvl2":"データの準備"},"content":"pygmt.makecpt でカラーパレットファイルを作成できます．\nデフォルトでは，作成したカラーパレットがそのセッションの標準として登録され，それ以降のコマンドでのカラーパレットとして自動的に利用されます．\n\n複数のカラーパレットを同時に使い分けたいなど，明示的にカラーパレットを指示したいときには，pygmt.makecpt  の output オプションでファイル名を指定して .cpt ファイルを作成することもできます．その場合には，plot コマンドの cmap オプションにはその .cpt ファイル名を指定します．\n\nまた，fig.colorbar は指定あるいは標準のカラーパレットに基づきカラースケールを描画します．位置指定を明示的にしない場合には，直前に描画した図の下部中央に配置されます．frame には数多くの指定ができるようですが，特に +eを指定すると，カラースケールの上限と下限を超えた値の色をカラースケール両側の三角形に示してくれます．","type":"content","url":"/inf-on-map#id-3","position":9},{"hierarchy":{"lvl1":"PyGMTの環境構築"},"type":"lvl1","url":"/install","position":0},{"hierarchy":{"lvl1":"PyGMTの環境構築"},"content":"","type":"content","url":"/install","position":1},{"hierarchy":{"lvl1":"PyGMTの環境構築","lvl2":"Google Colab 上での利用"},"type":"lvl2","url":"/install#google-colab","position":2},{"hierarchy":{"lvl1":"PyGMTの環境構築","lvl2":"Google Colab 上での利用"},"content":"手軽にPyGMTを試すためには，\n\nGoogle Colabを利用するのがよいでしょう．Google ColabはGoogleが機械学習の教育及び研究用に提供しているもので，Googleアカウントさえあればクラウド上でJupyter Notebookを実行できます．大量の計算リソースを使うためには有料のサービスもありますが，本Webページで示しているくらいの可視化を行う程度の基本的な利用は無料です．\n\nGoogle Colabには，機械学習等で使われる標準的なパッケージはあらかじめ含まれているのですが，残念ながらPyGMTは含まれていません．すでに多くの関連Webでも紹介されていますが（例えば\n\nPyGMT開発メンバーのseisman 氏のGMT Forum, \n\nafter-a-rain 氏のQiita記事や\n\nmim 氏のnote記事など），比較的容易にインストールすることができます．import sys\nif 'google.colab' in sys.modules:\n    print(\"Installing pygmt on Google Colab. It may take a few minutes.\")\n    ! pip install -q condacolab &> /dev/null\n    import condacolab\n    condacolab.install()\n    ! mamba install pygmt &> /dev/null\n\n上記のコードは，Google Colabで実行したときにだけPyGMTをインストールするためのコードです．それ以外の環境では実行されないようにもなっています．これをColab上のノートブックのセルに貼り付けて実行するか，あるいは\n\nこちらのリンクからサンプルのノートブックを開くことでも実行できます．\n\nNote\n\nインストールには約2分ほどの時間かかります．インストール時にカーネルがクラッシュした旨のメッセージが出ることがありますが，そのまま進めて特に問題はなさそうです．\n\nまた，Google Colabの仕様により，この方法でインストールしたPyGMTは，そのセッション限りで有効です．そのため，毎回セッションを開始するたびに上記のコードを実行する必要があります．毎回のインストール作業が鬱陶しいようであれば，以下の節で説明するローカル環境へのインストールをお勧めします．","type":"content","url":"/install#google-colab","position":3},{"hierarchy":{"lvl1":"PyGMTの環境構築","lvl2":"ローカル環境へのインストール"},"type":"lvl2","url":"/install#id","position":4},{"hierarchy":{"lvl1":"PyGMTの環境構築","lvl2":"ローカル環境へのインストール"},"content":"Warning\n\n本節の記述はmacOSおよびUbuntuで動作確認しています．Windows OSにおいても\n\nWSL2を用いることでUbuntuをはじめとしたLinuxディストリビューションを容易に利用可能なはずです．Windows ネイティブ環境におけるインストールについては，本サイトでは扱いません．\n\nPyGMTを使うための環境構築には，Pythonのパッケージ管理システムである\n\nconda\n\npip\n\nのどちらかを使います．原理的には自分でソースコードから構築することもできるはずですが，PyGMTはそれを動作させるための依存ライブラリがとても多いため，パッケージ管理システムを使うことを勧めます．\n\npipはPythonに付属したツールで，Python上で用いるライブラリの管理を行うものである一方，condaはPythonの処理系自体を含むパッケージで，Pythonのみならずそれに（広い意味で）関連した様々なツールをインストールできます．\n\nどちらを使うかは好みの問題だと思いますが，PyGMTについてはcondaのほうが比較的に容易に環境が構築できるようです．ただし，condaはライセンスまわりにやや注意が必要です．","type":"content","url":"/install#id","position":5},{"hierarchy":{"lvl1":"PyGMTの環境構築","lvl3":"Anacondaライセンス問題とMiniforgeの利用","lvl2":"ローカル環境へのインストール"},"type":"lvl3","url":"/install#anaconda-miniforge","position":6},{"hierarchy":{"lvl1":"PyGMTの環境構築","lvl3":"Anacondaライセンス問題とMiniforgeの利用","lvl2":"ローカル環境へのインストール"},"content":"conda コマンドはもともとAnacondaという科学技術計算に必要なライブラリが多く含まれたPython実行環境とそのパッケージ管理システムの一部でした．Anacondaをインストールするだけで一通りの計算環境が揃うためたいへん便利なものだったのですが，2020年4月より利用規約が\n\n改定となり，大規模な商用利用は有償になりました．その時点では大学関係者や非商用利用に関してはこの条件は適用されないと\n\n明記されていたのですが，その後さらにライセンス条件が変更され，2024年現在，事実上Anacondaの無償利用は困難な状況になったようです．\n\nそこで，ここではPythonおよびパッケージ管理コマンドのcondaを含むコミュニティベースのパッケージ管理システムである\n\nminiforgeを利用し，PyGMTの環境を構築します．\n\nWarning\n\n以前，このページでは\n\nMinicondaとコミュニティベースのリポジトリである conda-forge の利用を推奨し，その方法について説明していました．しかしMinicondaはデフォルトの状態ではAnaconda本体のリポジトリを利用する設定となっているため，そのままではライセンスに抵触するおそれがあります．そこで，今後はコミュニティリポジトリのconda-forgeをデフォルトで使いつつ，従来のcondaと同じ使い方のできるMiniforgeの利用を推奨します．","type":"content","url":"/install#anaconda-miniforge","position":7},{"hierarchy":{"lvl1":"PyGMTの環境構築","lvl4":"Miniforgeのインストール","lvl3":"Anacondaライセンス問題とMiniforgeの利用","lvl2":"ローカル環境へのインストール"},"type":"lvl4","url":"/install#miniforge","position":8},{"hierarchy":{"lvl1":"PyGMTの環境構築","lvl4":"Miniforgeのインストール","lvl3":"Anacondaライセンス問題とMiniforgeの利用","lvl2":"ローカル環境へのインストール"},"content":"まずは適当なディレクトリで，miniforgeをダウンロードします．ここではcurlコマンドを使った例を示します．curl -L -O \"https://github.com/conda-forge/miniforge/releases/latest/download/Miniforge3-$(uname)-$(uname -m).sh\"\n\nダウンロードしたら，そのスクリプトを bash コマンドで実行します．bash Miniforge3-$(uname)-$(uname -m).sh\n\nあとは対話的に y/n を選んでいくことでMiniforgeインストールできます．その際，インストール先も指定できます．デフォルトは~/miniforge3のはずです．ただし~は自分のホームディレクトリを意味します．インストール時にnoと答えていなければ，自分のシェル設定ファイル（.bashrcあるいは.zshrc）にcondaコマンドを実行するための初期設定が書き込まれます．これにより，次回端末（あるいはシェル）起動時より，ターミナルのプロンプトに (base) と表示されるはずです．これはcondaのbase仮想環境（標準状態）であることを意味します．\n\nこれでインストール作業は終わりですが，conda自体を最新版にアップデートしておきましょう．conda update conda","type":"content","url":"/install#miniforge","position":9},{"hierarchy":{"lvl1":"PyGMTの環境構築","lvl3":"仮想環境の作成とPyGMTのインストール","lvl2":"ローカル環境へのインストール"},"type":"lvl3","url":"/install#id-pygmt","position":10},{"hierarchy":{"lvl1":"PyGMTの環境構築","lvl3":"仮想環境の作成とPyGMTのインストール","lvl2":"ローカル環境へのインストール"},"content":"このままデフォルトの環境にパッケージを追加していってもよいのですが，ここではPyGMT用の仮想環境を作成します．このようにすると，パッケージ間のバージョン不整合などのトラブルがあったときに，仮想環境ごと切り替えるということが可能になります．ここでは，本Webサイトで利用するパッケージをまるごと導入する仮想環境pygmtを作ってみましょう．ここでは，2025年8月時点で最新となるPyGMT v0.16.0と，GMT v6.6.0 を導入します．$ conda create --name pygmt17 \\\n  pygmt==0.17.0 gmt==6.6.0 numpy scipy obspy==1.4.2 notebook matplotlib ffmpeg\n\nNote\n\nコマンドが長いため \\で適宜改行しています．仮想環境の名前 pygmt はお好みで適宜変更するとよいでしょう．\n\n上記のコマンドでは，まず --name オプションで仮想環境の名前を宣言し，そのあとでインストールする各種パッケージと必要に応じてそのバージョンを == でつないで表現しています．PyGMTのほか，科学技術計算に必要なNumPyやSciPy，地震学データ解析に用いるObsPy，実行環境としてJupyter Notebook(notebookがそれにあたります）などをまとめてインストールします．\n\n上記コマンドからわかるように，conda ではPythonのライブラリだけではなく，GMTそのものもインストールされます．ですから，この環境構築方法では，GMTを別途インストールしておく必要はありません．今回作成した仮想環境のbashから，GMT自体も使うことができます．また，Python本体も指定したバージョンのものがインストールされます．ライブラリやPythonのバージョン番号は指定しなければ最新版が入ります．\n\nTip\n\nこれらのライブラリや実行バイナリは，miniforge のインストールディレクトリ下の envs ディレクトリに格納されます．miniforgeをデフォルトでホームディレクトリにインストールしている場合，容量の増大にはご注意ください．\n\nインストールが完了したらconda activate pygmt17\n\nにより仮想環境を有効化します．すると，プロンプトの左側の (base) が仮想環境の名前 (pygmt) に変わります．もしいつでもこの環境を使いたいならば，シェルの初期設定ファイル（.bashrc あるいは .zshrc など）に上記の activate コマンドを記載しておくとよいでしょう．\n\n一方，仮想環境から抜けるにはconda deactivate\n\nです．もしこの仮想環境が不要になって削除したいときは，仮想環境からconda deactivate した状態でconda remove -n pygmt17 --all\n\nとします．","type":"content","url":"/install#id-pygmt","position":11},{"hierarchy":{"lvl1":"日本語フォントの利用"},"type":"lvl1","url":"/japanese","position":0},{"hierarchy":{"lvl1":"日本語フォントの利用"},"content":"Danger\n\n本ページで解説している内容の再現性はOSやソフトウェアのインストール状況に依存する可能性があります．また，これが最良の方法とは限りません．より良い方法をご存知のかたはぜひ \n\nIssues でお知らせください．\n\n","type":"content","url":"/japanese","position":1},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl2":"PyGMTにおけるフォント指定"},"type":"lvl2","url":"/japanese#pygmt","position":2},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl2":"PyGMTにおけるフォント指定"},"content":"GMTではあらかじめ40種弱のフォントが指定されており，コマンドラインの gmt text -L によりその一覧を出力することができます．以下はその一部です．\n\nフォント番号\n\n名前\n\n0\n\nHelvetica\n\n1\n\nHelvetica-Bold\n\n2\n\nHelvetica-Oblique\n\n3\n\nHelvetica-BoldOblique\n\n4\n\nTimes-Roman\n\n5\n\nTimes-Bold\n\n6\n\nTimes-Italic\n\n7\n\nTimes-BoldItalic\n\n8\n\nCourier\n\n9\n\nCourier-Bold\n\n10\n\nCourier-Oblique\n\n11\n\nCourier-BoldOblique\n\n.\n\n（中略）\n\n35\n\nRyumin-Light-EUC-H\n\n36\n\nRyumin-Light-EUC-V\n\n37\n\nGothicBBB-Medium-EUC-H\n\n38\n\nGothicBBB-Medium-EUC-V\n\nこれらのフォントは，たとえば fig.text() モジュールの font オプションに名前あるいは番号で，font = '12p,Times-Italic,Black'\n\nやfont = '10p,8,Black'\n\nのように指定することができます．\n\nまた，軸ラベルなどの任意の文字列に対して， @%(フォント番号)% と @%% で囲まれた文字列を指定のフォント番号で表示できます．次の図はアルファベットを表示可能なすべてのフォントを使った例です．ただし12 Symbolだけはギリシャ文字のアルファベットになります．\n\nimport pygmt\n\nfig = pygmt.Figure()\n\nfig.basemap(projection='X16c/10c', region=[0, 16, 0, 10], \n            frame = ['WSen+t@%0%0 Helvetica@%%', \n                     'xaf+l@%1%1 Helvetica-Bold@%%', \n                     'yaf+l@%2%2 Helvetica-Oblique@%%'])\nfig.text(x=0.5, y=9.5, justify='LM', font='12p,4,Black',  text='3 Helvetica-BoldOblique')\nfig.text(x=0.5, y=9.0, justify='LM', font='12p,4,Black',  text='4 Times-Roman')\nfig.text(x=0.5, y=8.5, justify='LM', font='12p,5,Black',  text='5 Times-Bold')\nfig.text(x=0.5, y=8.0, justify='LM', font='12p,6,Black',  text='6 Times-Italic')\nfig.text(x=0.5, y=7.5, justify='LM', font='12p,7,Black',  text='7 Times-BoldItalic')\nfig.text(x=0.5, y=7.0, justify='LM', font='12p,8,Black',  text='8 Courier')\nfig.text(x=0.5, y=6.5, justify='LM', font='12p,9,Black',  text='9 Courier-Bold')\nfig.text(x=0.5, y=6.0, justify='LM', font='12p,10,Black', text='10 Courier-Oblique')\nfig.text(x=0.5, y=5.5, justify='LM', font='12p,11,Black', text='11 Courier-BoldOblique')\nfig.text(x=0.5, y=5.0, justify='LM', font='12p,12,Black', text='12 Symbol')\nfig.text(x=0.5, y=4.5, justify='LM', font='12p,13,Black', text='13 AvantGarde-Book')\nfig.text(x=0.5, y=4.0, justify='LM', font='12p,14,Black', text='14 AvantGarde-BookOblique')\nfig.text(x=0.5, y=3.5, justify='LM', font='12p,15,Black', text='15 AvantGarde-Demi')\nfig.text(x=0.5, y=3.0, justify='LM', font='12p,16,Black', text='16 AvantGarde-DemiOblique')\nfig.text(x=0.5, y=2.5, justify='LM', font='12p,17,Black', text='17 Bookman-Demi')\nfig.text(x=0.5, y=2.0, justify='LM', font='12p,18,Black', text='18 Bookman-DemiItalic')\nfig.text(x=0.5, y=1.5, justify='LM', font='12p,19,Black', text='19 Bookman-Light')\nfig.text(x=0.5, y=1.0, justify='LM', font='12p,20,Black', text='20 Bookman-LightItalic')\nfig.text(x=0.5, y=0.5, justify='LM', font='12p,21,Black', text='21 Helvetica-Narrow')\nfig.text(x=8.5, y=9.5, justify='LM', font='12p,22,Black', text='22 Helvetica-Narrow-Bold')\nfig.text(x=8.5, y=9.0, justify='LM', font='12p,23,Black', text='23 Helvetica-Narrow-Oblique')\nfig.text(x=8.5, y=8.5, justify='LM', font='12p,24,Black', text='24 Helvetica-Narrow-BoldOblique')\nfig.text(x=8.5, y=8.0, justify='LM', font='12p,25,Black', text='25 NewCenturySchlbk-Roman')\nfig.text(x=8.5, y=7.5, justify='LM', font='12p,26,Black', text='26 NewCenturySchlbk-Italic')\nfig.text(x=8.5, y=7.0, justify='LM', font='12p,27,Black', text='27 NewCenturySchlbk-Bold')\nfig.text(x=8.5, y=6.5, justify='LM', font='12p,28,Black', text='28 NewCenturySchlbk-BoldItalic')\nfig.text(x=8.5, y=6.0, justify='LM', font='12p,29,Black', text='29 Palatino-Roman')\nfig.text(x=8.5, y=5.5, justify='LM', font='12p,30,Black', text='30 Palatino-Italic')\nfig.text(x=8.5, y=5.0, justify='LM', font='12p,31,Black', text='31 Palatino-Bold')\nfig.text(x=8.5, y=4.5, justify='LM', font='12p,32,Black', text='32 Palatino-BoldItalic')\nfig.text(x=8.5, y=4.0, justify='LM', font='12p,33,Black', text='33 ZapfChancery-MediumItalic')\nfig.show(crop=0.5, width=800)\n\nGMTのデフォルトで設定される一連のフォントのなかに， 35: Ryumin-Light-EUC-H\n 36: Ryumin-Light-EUC-V\n 37: GothicBBB-Medium-EUC-H\n 38: GothicBBB-Medium-EUC-V\n\nという4つのフォントがあります．35と36はリュウミン（明朝体），37と38はゴシック体なのですが，文字コードがEUCのため，UTF-8コードが標準のPythonではそのまま使うことができません．\n\nNote\n\nUTF-8が普及した現在はあまり使われなくなりましたが，昔は日本語を表す文字コードにWindows系でよく用いられるShift-JISと，Unix系で用いられたEUCが混在していて，互いに変換が必要でした．\n\nまた，PyGMTのバックエンドであるGMTが画像として最初に生成するPostScript形式のファイルをPNGやPDF形式に変換する（fig.show()コマンドでも内部でそのような変換が走っています）際に用いられる ghostscript というプログラムがあるのですが，日中韓のフォント（CJKフォント）を用いるためには＋アルファの手当が必要で，condaでPyGMTと一緒にインストールされたghostscriptでは（筆者が試した限り）うまくいかないようでした．\n\nそこで，PyGMTで日本語を扱うためには，\n\n日本語フォントの準備\n\nghostscriptを別途導入\n\n日本語フォント利用のための設定\n\nが必要です．ところが，フォントのインストール先や扱いがOSによって異なるため，あらゆる環境で統一的にうまくいく方法はなさそうです．以下では筆者環境（Ubuntu 22.04.4 LTS）で動作した方法を標準として紹介し，macOSについて後から補足します．Ubuntuの派生Linux（Linux Mintなど）はほとんど同じように動くと思われますが，RedHat系ではファイルの置き場が大きく異なる可能性があります．\n\n","type":"content","url":"/japanese#pygmt","position":3},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl2":"Ubuntu Linuxにおける設定"},"type":"lvl2","url":"/japanese#ubuntu-linux","position":4},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl2":"Ubuntu Linuxにおける設定"},"content":"","type":"content","url":"/japanese#ubuntu-linux","position":5},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl3":"1. フォントのインストール","lvl2":"Ubuntu Linuxにおける設定"},"type":"lvl3","url":"/japanese#id-1","position":6},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl3":"1. フォントのインストール","lvl2":"Ubuntu Linuxにおける設定"},"content":"デスクトップ版のOSを導入していたらおそらくインストール済みですが，デフォルトの Takao フォントを用います．$ sudo apt install fonts-takao\n\nこのフォントは\n\n/usr/share/fonts/truetype/takao-gothic/TakaoPGothic.ttf\n\n/usr/share/fonts/truetype/takao-mincho/TakaoPMincho.ttf\n\nにインストールされます．\n\n","type":"content","url":"/japanese#id-1","position":7},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl3":"2. システムに ghostscript を導入","lvl2":"Ubuntu Linuxにおける設定"},"type":"lvl3","url":"/japanese#id-2-ghostscript","position":8},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl3":"2. システムに ghostscript を導入","lvl2":"Ubuntu Linuxにおける設定"},"content":"$ sudo apt install ghostscript poppler-data\n\nNote\n\npoppler-data は旧 gs-cjk-resource に代わるもので，日中韓のフォント利用に関するファイルがインストールされるようです．\n\nGhostscriptのバイナリは /usr/bin/gs に配置されます．\n\n","type":"content","url":"/japanese#id-2-ghostscript","position":9},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl3":"3. cidfmap ファイルの確認","lvl2":"Ubuntu Linuxにおける設定"},"type":"lvl3","url":"/japanese#id-3-cidfmap","position":10},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl3":"3. cidfmap ファイルの確認","lvl2":"Ubuntu Linuxにおける設定"},"content":"/var/lib/ghostscript/fonts/cidfmap を閲覧し，以下の行があることを確認してください．/Japanese-Mincho-Regular << /FileType /TrueType /Path (/usr/share/fonts/truetype/fonts-japanese-mincho.ttf) /SubfontID 0 /CSI [(Japan1) 4] >> ;\n/Japanese-Gothic-Regular << /FileType /TrueType /Path (/usr/share/fonts/truetype/fonts-japanese-gothic.ttf) /SubfontID 0 /CSI [(Japan1) 4] >> ;\n/Ryumin-Light /Japanese-Mincho-Regular ;\n/GothicBBB-Medium /Japanese-Gothic-Regular ;\n\nTip\n\n書式を真似て，第1列のフォント名と /Path () を変えることで新たなフォントを追加することもできます（IPAexフォントで動作確認済）．ただし，拡張子が .ttc のTrueType Collection形式は読めないようです．\n\nNote\n\nUbuntuでは /usr/share/fonts/truetype/fonts-japanese-mincho.ttf は /etc/alternatives/fonts-japanese-mincho.ttf を介して Takao明朝 /usr/share/fonts/truetype/takao-mincho/TakaoPMincho.ttf に紐づけられています．ゴシックも同様です．\n\ncidfmap ファイルの先頭列の名前がPyGMTにおけるフォント名の基本部分になります．\n\n","type":"content","url":"/japanese#id-3-cidfmap","position":11},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl3":"4. PSL_custom_fonts.txt の作成","lvl2":"Ubuntu Linuxにおける設定"},"type":"lvl3","url":"/japanese#id-4-psl-custom-fonts-txt","position":12},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl3":"4. PSL_custom_fonts.txt の作成","lvl2":"Ubuntu Linuxにおける設定"},"content":"ユーザーのホームディレクトリ直下の .gmt/PSL_custom_fonts.txt ファイルを編集し（なければ作る）．以下の2行を追加します．Ryumin-Light-UniJIS-UTF8-H 0.700 1\nGothicBBB-Medium-UniJIS-UTF8-H 0.700 1\n\n第1列の Ryumin-Light と GothicBBB-Medium が cidfmap の記述の第1列に存在することが重要です．\n\nTip\n\n上記設定ファイルはユーザーごとに設定する必要がありますが，PyGMTを仮想環境ごとシステムにインストールしている場合など複数ユーザーに同時に効かせたいときには， (condaインストール先)/envs/(conda仮想環境名)/share/gmt/PSL_custom_fonts.txt に設定を書いても有効となります．\n\n","type":"content","url":"/japanese#id-4-psl-custom-fonts-txt","position":13},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl3":"5. フォント設定状況の確認","lvl2":"Ubuntu Linuxにおける設定"},"type":"lvl3","url":"/japanese#id-5","position":14},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl3":"5. フォント設定状況の確認","lvl2":"Ubuntu Linuxにおける設定"},"content":"GMTのインストールされている環境のターミナルから，コマンドラインで gmt text -L を実行して，フォント一覧を確認します．$ gmt text -L\ngmt text [core] 6.6.0 [64-bit] [MP] - Plot or typeset text\n\n（中略）\n\n     35: Ryumin-Light-EUC-H\n     36: Ryumin-Light-EUC-V\n     37: GothicBBB-Medium-EUC-H\n     38: GothicBBB-Medium-EUC-V\n     39: Ryumin-Light-UniJIS-UTF8-H\n     40: GothicBBB-Medium-UniJIS-UTF8-H\n     ------------------------------------\n     For additional fonts, see \"Using non-default fonts with GMT\" in the documentation.\n\nこの場合は39-40番に今回追加したフォントが表示されるはずです．ここまでで設定完了です．\n\n","type":"content","url":"/japanese#id-5","position":15},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl3":"6. gs_path の明示指定","lvl2":"Ubuntu Linuxにおける設定"},"type":"lvl3","url":"/japanese#id-6-gs-path","position":16},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl3":"6. gs_path の明示指定","lvl2":"Ubuntu Linuxにおける設定"},"content":"PyGMTで作られた画像オブジェクト fig は，内部的にはPostScript形式の画像を持っており，fig.show() や. fig.savefig(), fig.ps2raster() などの表示や画像保存のメソッドを呼び出した際に，外部ツールとして Ghostscript を呼び出して png や pdfといった画像に変換しているようです．ここで行った設定を利用するには，PyGMTの依存関係として自動的にconda環境にインストールされたghostscriptではなく，手順2で手動インストールしたほうのghostscriptを使う必要があります．\n\nそこで，gs_path=\"/usr/bin/gs\" というオプションを .show(), .savefig(), .ps2raster() に指定します．これで利用するghostscriptを指定し，日本語フォントを正しく読み込むことができるようになります．\n\n","type":"content","url":"/japanese#id-6-gs-path","position":17},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl2":"macOSの場合"},"type":"lvl2","url":"/japanese#macos","position":18},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl2":"macOSの場合"},"content":"Ubuntuと同様に，conda 外で ghostscript をインストールして使うのですが，\n\n昔のLaTeXでは同様のメカニズムでghostscriptからヒラギノフォントを使っていたようなので，設定次第でできる気がするのですが・・・\n\ncidfmap の場所が異なる\n\nmacOSのデフォルトのフォントが（筆者の試した限り）うまく読み込めない\n\nという問題があります．そこで，ユーザー領域に追加フォントを導入して，それを利用する方向で対策してみます．\n\n","type":"content","url":"/japanese#macos","position":19},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl3":"1. フォントのインストール","lvl2":"macOSの場合"},"type":"lvl3","url":"/japanese#id-1-1","position":20},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl3":"1. フォントのインストール","lvl2":"macOSの場合"},"content":"モリサワのユニバーサルデザインフォント \n\nBIZ UD明朝 と\n\nBIZ UDゴシック がGoogle Fontsからダウンロードできるので，まずはこれらをインストールします．ダウンロードしたフォントファイルをダブルクリックしてインストールボタンを押すと，/Users/ユーザー名/Library/Fonts 以下にファイルが配置されるはずです．\n\nTip\n\n後述の Homebrew をつかって$ brew install font-biz-udgothic font-biz-udmincho\n\nとしてもOKです．\n\n","type":"content","url":"/japanese#id-1-1","position":21},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl3":"2. システムに ghostscript を導入","lvl2":"macOSの場合"},"type":"lvl3","url":"/japanese#id-2-ghostscript-1","position":22},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl3":"2. システムに ghostscript を導入","lvl2":"macOSの場合"},"content":"macOSのパッケージ管理システム \n\nHomebrew を用いてインストールします．もしHomebrewをインストールしていなかったら \n\nhttps://brew.sh の解説の通りにインストールし，ターミナルから$ brew install ghostscript\n\nによりインストールします．GhostscriptのバイナリはHomebrewのデフォルト設定なら /opt/homebrew/bin/gs に配置されるはずです．\n\n","type":"content","url":"/japanese#id-2-ghostscript-1","position":23},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl4":"3. cidfmap ファイルの編集","lvl3":"2. システムに ghostscript を導入","lvl2":"macOSの場合"},"type":"lvl4","url":"/japanese#id-3-cidfmap-1","position":24},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl4":"3. cidfmap ファイルの編集","lvl3":"2. システムに ghostscript を導入","lvl2":"macOSの場合"},"content":"/opt/homebrew/share/ghostscript/Resource/Init/cidfmap を適当なテキストエディタで編集し，以下の行を追記します．ただし，「ユーザー名」はご自身のmacOSのユーザー名に変更してください．/Japanese-Mincho-Regular << /FileType /TrueType /Path (/Users/ユーザー名/Library/Fonts/BIZUDMincho-Regular.ttf) /SubfontID 0 /CSI [(Japan1) 2] >> ;\n/Japanese-Gothic-Regular << /FileType /TrueType /Path (/Users/ユーザー名/Library/Fonts/BIZUDGothic-Regular.ttf) /SubfontID 0 /CSI [(Japan1) 2] >> ;\n/Ryumin-Light /Japanese-Mincho-Regular ;\n/GothicBBB-Medium /Japanese-Gothic-Regular ;\n\n以下，手順 4・手順 5はUbuntuの場合と同じです．.show(), .savefig(), .ps2raster() に指定すべき gs_path オプションの値はLinuxと異なり，gs_path=\"/opt/homebrew/bin/gs\" です．\n\n","type":"content","url":"/japanese#id-3-cidfmap-1","position":25},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl2":"日本語フォントの指定"},"type":"lvl2","url":"/japanese#id","position":26},{"hierarchy":{"lvl1":"日本語フォントの利用","lvl2":"日本語フォントの指定"},"content":"ここまでの設定ができていれば，本ページ冒頭で説明したものと同じ要領で，\n\n39: Ryumin-Light-UniJIS-UTF8-H\n\n40: GothicBBB-Medium-UniJIS-UTF8-H\n\nのフォントをそれぞれ使えます．名前が長いので番号で使うのが簡単でしょう．39番が明朝体，40番がゴシック体です．\n\n以下はmacOS環境で実際に日本語を用いた地図の例です．\n\nimport pygmt\n\nfig = pygmt.Figure()\nwith pygmt.config(\n    FONT_ANNOT_PRIMARY   = '12p,Helvetica,black',\n    FONT_ANNOT_SECONDARY = '11p,Helvetica,black',\n    FONT_LABEL           = '14p,Helvetica,black',\n    FONT_TITLE           = '14p', \n    MAP_GRID_PEN_PRIMARY = '0.25p,30/30/30,.',\n    MAP_FRAME_TYPE       = 'plain',\n    FORMAT_GEO_MAP       = 'DF',\n    FORMAT_FLOAT_OUT     = '%.1f',\n    PS_IMAGE_COMPRESS    = 'none',\n    PS_LINE_CAP          = 'round',\n    PS_LINE_JOIN         = 'round'\n):\n    fig.coast(projection='M12c', region=[139.7, 141.8, 40.3, 41.6], \n              resolution='full', area_thresh = 50, \n              shorelines = 'thinnest,black', water = '250', \n              frame = ['WSen+t@%40%青森県の県庁・市庁所在地@%%', #<-- @%40% .. @%% でフォント指定\n                       'xaf', 'yaf']) \n    fig.plot(x = [140.740005, 140.464008, 141.488404, 140.594547, 140.446118, \n                  141.205910, 141.369093, 141.183174, 140.380195, 140.567123], \n             y = [40.824440, 40.602965, 40.512278, 40.642608, 40.807835, \n                  40.612703, 40.683078, 41.292835, 40.808836, 40.583742], \n             style = 'c0.2c', fill='150/100/250', pen='thin,black')\n    fig.text(x = [140.740005, 140.464008, 141.488404, 140.594547, 140.446118, \n                  141.205910, 141.369093, 141.183174, 140.380195, 140.567123], \n             y = [40.824440, 40.602965, 40.512278, 40.642608, 40.807835, \n                  40.612703, 40.683078, 41.292835, 40.808836, 40.583742], \n             offset = '0c/-0.2c', \n             font='8p,40,Black',  #<-- 日本語フォントを指定\n             text = ['青森', '弘前', '八戸', '黒石', '五所川原', \n                     '十和田', '三沢', 'むつ', 'つがる', '平川'], \n             justify=['CT','RT','CT','LT','LT','CT','CT','CT','RT', 'CT'], \n             fill='white@20%', clearance='0.05')\n             \nfig.show(gs_path='/opt/homebrew/bin/gs', dpi=600, width=800)\n\nTip\n\nPyGMTの fig.show() メソッドは，PostScript形式で作成されていた図をラスター画像にしてJupyter Notebookに表示します．その際 dpi=150 の解像度が仮定されているようです．多くの場合には困りませんが，日本語で細かい字を表示するとガタツキが気になる場合があります．そのようなときには，上記の例のように dpi=300からdpi=600 程度を指定すると滑らかになります．当然ですが埋め込まれる画像のファイルサイズは大きくなります．","type":"content","url":"/japanese#id","position":27},{"hierarchy":{"lvl1":"License"},"type":"lvl1","url":"/license","position":0},{"hierarchy":{"lvl1":"License"},"content":"Copyright (C) 2021-2025 \n\nTakuto Maeda\n\nWebサイトで公開されるコンテンツは\n\nクリエイティブ・コモンズ4.0表示（CC-BY 4.0)で提供します．また，本Webサイトを生成するためのソースコードおよびWebサイト中に含まれる\n\nソースコードは\n\nMITライセンスで提供します．\n\nThe web contents are distributed under \n\nCC-BY 4.0. The source codes to build this web contents, and codes appered inside the web contents are distributed under \n\nMIT license.","type":"content","url":"/license","position":1},{"hierarchy":{"lvl1":"震源メカニズム解の表現"},"type":"lvl1","url":"/mech","position":0},{"hierarchy":{"lvl1":"震源メカニズム解の表現"},"content":"import pygmt\nimport numpy as np\n\n震源メカニズムは辞書形式でデータを渡すのがわかりやすそうです．\n\nmeca ={\n    \"strike\"   : [ 35,  15], \n    \"dip\"      : [ 45,  35], \n    \"rake\"     : [ 90, 120], \n    \"magnitude\": [  6,   4], \n    \"longitude\": [135, 140],\n    \"latitude\" : [ 35,  40], \n    \"depth\"    : [ 30, 400]\n}\n\nこの例のように，strike, dip, rake が指定されると自動的にAki and Richardsフォーマットが選択されます．公式マニュアルによると，その他のフォーマットは以下のような辞書項目が設定されていれば良いようです：\n\nformat\n\ndictionary keys\n\naki\n\nstrike, dip, rake, magnitude\n\ngcmt\n\nstrike1, dip1, rake1, strike2, dip2, rake2, mantissa, exponent\n\nmt\n\nmrr, mtt, mff, mrt, mrf, mtf, exponent\n\npartial\n\nstrike1, dip1, strike2, fault_type, magnitude\n\nprincipal_axis\n\nt_exponent, t_azimuth, t_plunge, n_exponent, n_azimuth, n_plunge, p_exponent, p_azimuth, p_plunge, exponent\n\nspec として渡された辞書のkeyに基づいて，フォーマットが自動判定されます．\n\n複数のメカニズム解を表現したい場合は，辞書のそれぞれのキーに対応する値をリストやタプルにします．同じ構造を持つ辞書全体のリストを一括で処理することはできないようです．（とはいえ，Pythonの for 構文と組み合わせればそれは容易に実現できます）\n\nfig = pygmt.Figure()\n\nfig.coast(\n    projection  = 'M12c', \n    region      = [128, 146, 30, 46], \n    land        = 'grey', \n    water       = 'lightblue', \n    shorelines  = 'default,black', \n    area_thresh = 10,                           \n    resolution  = 'f', \n    frame       = ['WSen', 'xaf', 'yaf'], \n    map_scale   = '142/31/31/500'\n)\n\npygmt.makecpt(\n    cmap         = 'seis',       \n    series       = [0, 700, 50], \n    background   = True,         \n    continuous   = True, \n    transparency = 40, \n)\n\nfig.meca(spec  = meca, \n         scale = '1c', \n         cmap  = True, \n         outline = 'default,black'\n)\n\nfig.show()\n\nNote\n\n2023年9月公開のPyGMT v0.10.0 でmeca モジュールのオプションの実装が進み，GMT本家の T オプションに相当する outline が実装されて，だいぶ使いやすくなりました．\n\nそれ以前のバージョンでは，メカニズム解の押し部分への色塗りをひとつのモジュール呼び出しにまとめることができず，上記のスクリプトの fig.meca 部分を，以下のように2段階に分けて書く必要がありました．最新版を使うことをお勧めしますが，旧版をお使いの方のために情報として残しておきます．fig.meca(spec  = meca, \n         scale = '1c', \n         cmap  = True, \n)\n\n# 節面を描画するにはもういちど fig.meca を `T` オプションをつけて呼ぶ\nfig.meca(\n    spec  = meca, \n    scale = '1c', \n    pen   = 'default,black', \n    T = '0'\n)\n\nなお，meca の outline オプションについては，染矢さん(\n\n@msomeya1) に\n\nご教示いただきました．記して感謝いたします．\n\n","type":"content","url":"/mech","position":1},{"hierarchy":{"lvl1":"震源メカニズム解の表現","lvl2":"メカニズム解の鉛直断面表示"},"type":"lvl2","url":"/mech#id","position":2},{"hierarchy":{"lvl1":"震源メカニズム解の表現","lvl2":"メカニズム解の鉛直断面表示"},"content":"地図上ではなく，ある側線に沿った鉛直断面におけるメカニズム解を表示することがあります．このようなとき，プロットされるメカニズム解は水平な地図上での下半球投影ではなく，それを断面の角度に応じて投影したものを表示することが通例です．たとえば東西-鉛直断面を南側から見た場合，その断面の奥側，すなわち東半球が投影されます．\n\nGMTでは，このような目的で \n\ncoupe というモジュールが提供されています．このモジュールはまさに上記のような目的を叶えるもので，震源メカニズムを鉛直断面上に表示します．\n\n本家GMTにおけるcoupe利用の簡単な例として，3つのメカニズム解の東西鉛直断面と南北鉛直断面を表示するスクリプトの例を以下に示します．#!/bin/bash\n\nstrike=180\ndip1=5\ndip2=80\ndip3=15\nrake1=30\nrake2=15\nrake3=-80\n\necho \"1 3 1 $strike $dip1 $rake1 5 0 0\" > meca.dat\necho \"2 2 1 $strike $dip2 $rake2 5 0 0\" >> meca.dat\necho \"3 1 1 $strike $dip3 $rake3 5 0 0\" >> meca.dat\n\ngmt begin coupe_test png\n\n    gmt basemap -R0/4/0/4 -JX10c/10c -BWseN -Bxaf+l\"Easting\" -Byaf+l\"Northing\" \n    gmt meca meca.dat -Sa2c -Gred -L \n\n    echo \"1 3.5 ($strike, $dip1, $rake1)\" | gmt text -F+f10p,Helvetica+jCB \n    echo \"2 2.5 ($strike, $dip2, $rake2)\" | gmt text -F+f10p,Helvetica+jCB \n    echo \"3 1.5 ($strike, $dip3, $rake3)\" | gmt text -F+f10p,Helvetica+jCB \n    echo \"3.9 3.9 (@~f@~, @~d@~, @~l@~)\"  | gmt text -F+f12p,Helvetica+jRT\n\n    gmt coupe meca.dat -Ac0/2/4/2 -Sa2c -R0/4/0/2 -JX10c/-4c \\\n        -BWSen -Y-5c -Bxaf+l\"Easting\" -Bya1f0.2+l\"Depth\" -Gred -L\n    gmt coupe meca.dat -Ac2/0/2/4 -Sa2c -R0/4/0/2 -JX10c/-4c \\\n        -BWSen -Y-5.5c -Bxaf+l\"Northing\" -Bya1f0.2+l\"Depth\" -Gred -L\n    \ngmt end\n\n上記のスクリプトを実行すると，下図のようなメカニズム解とその鉛直断面図が得られます．\n\nNote\n\n本来であれば南北断面については，横軸に深さ，縦軸に南北方向という座標系を取りたいところですが，筆者の知る限り gmt coupe でそれを実現することはできなさそうです．\n\nただし，残念なことに，coupe はv.0.13.0ではまだPyGMTには本モジュールが実装されていません．\n\nこの問題については，産業総合技術研究所の\n\n佐脇さんが，独自実装したcoupe.py とその使い方を \n\n公開 されています．その中では実装の詳細についても解説されており，大変有意義です．\n\nもちろんそれを使えば用は足りるのですが，ここではモーメントテンソルそのものの回転に基づく別の方法を考えます．\n\n","type":"content","url":"/mech#id","position":3},{"hierarchy":{"lvl1":"震源メカニズム解の表現","lvl2":"モーメントテンソルと座標変換"},"type":"lvl2","url":"/mech#id-1","position":4},{"hierarchy":{"lvl1":"震源メカニズム解の表現","lvl2":"モーメントテンソルと座標変換"},"content":"PyGMTの meca モジュールは，（入力フォーマットは様々ですが，本質的には）モーメントテンソルを水平面内（XYもしくはlon-lat座標系）において下半球投影したものを可視化してくれます．ここでは，その meca モジュールはそのままに，モーメントテンソルのほうを座標変換してしまうことで，異なる方向から見たモーメントテンソルがプロットされるようにしてみます．具体的には，以下の図で模式的に示すような (X,Y,Z)から(X', Y', Z')（東西鉛直断面）あるいは(X\",Y\",Z\")（南北鉛直断面）のような変換を考えます．\n\n\n\nここでは，もともとのXYZ座標系として，Aki and Richards (2002)に倣って北（上）をX, 東（右）を Y, 深さ方向（奥）を Z としました．それに対して東西鉛直断面では，上が-Z, 右がY, 奥がZ'になりますから，X' = -Z, Y' = Y, Z' = X\n\nすなわち\\begin{pmatrix} X'\\\\Y'\\\\Z' \\end{pmatrix}\n=\n\\begin{pmatrix} 0 & 0 & -1\\\\ 0 & 1 & 0 \\\\ 1 & 0 & 0 \\end{pmatrix}\n\\begin{pmatrix} X\\\\Y\\\\Z \\end{pmatrix}\n\nで座標変換が表されます．\n\n同様に，上図から南北-鉛直断面を鉛直方向を右に表示するには，\\begin{pmatrix} X''\\\\Y''\\\\Z'' \\end{pmatrix}\n=\n\\begin{pmatrix} 1 & 0 & 0\\\\ 0 & 0 & 1 \\\\ 0 & -1 & 0 \\end{pmatrix}\n\\begin{pmatrix} X\\\\Y\\\\Z \\end{pmatrix}\n\nとすればよいことがわかります．\n\n一般に，座標系O(XYZ)からO(X'Y'Z')への座標変換が行列\\boldsymbol{R}で与えられるとき，O(XYZ)における2階のテンソル\\boldsymbol{M}はO(X'Y'Z')において\\boldsymbol{M}' = \\boldsymbol{R M R}^T\n\nと表されます．このことを用いると，東西鉛直断面表示をするためのモーメントテンソルは\\begin{pmatrix} M'_{xx} & M'_{xy} &M'_{xz} \\\\ M'_{xy} & M'_{yy} &M'_{yz} \\\\ M'_{xz} & M'_{yz} &M'_{zz} \\end{pmatrix}\n=\n\\begin{pmatrix} M_{zz} & - M_{yz} & -M_{xz} \\\\ - M_{yz} & M_{yy} & M_{xy} \\\\ - M_{xz} & M_{xy} & M_{xx} \\end{pmatrix}\n\n南北鉛直断面については，\\begin{pmatrix} M''_{xx} & M''_{xy} &M''_{xz} \\\\ M''_{xy} & M''_{yy} &M''_{yz} \\\\ M''_{xz} & M''_{yz} &M''_{zz} \\end{pmatrix}\n=\n\\begin{pmatrix} M_{xx} & M_{xz} & -M_{xy} \\\\ M_{xz} & M_{zz} & -M_{yz} \\\\ - M_{xy} & -M_{yz} & M_{yy} \\end{pmatrix}\n\nであることが導かれます．\n\nところで，もし aki フォーマットで strike, dip, rake および Mw をもってメカニズム解を指定した場合，上記の方法を用いるためには，まずそれをモーメントテンソル成分に変換しなければなりません．しかも，mecaモジュールの mt フォーマットは，極座標におけるモーメントテンソル成分を入力として要求します．\n\nまず，strike \\phi, dip \\delta, rake \\lambda と地震モーメント M_0 が与えられたとき，上図のような北をX軸にとる直交座標系におけるモーメントテンソルは，\\begin{align}\n    &M_{xx} = - M_0  (\\sin\\delta * \\cos\\lambda * \\sin2\\phi + \\sin2\\delta * \\sin\\lambda * \\sin\\phi * \\sin\\phi )\\\\\n    &M_{xy} = \\,\\,\\,\\, M_0  (\\sin\\delta * \\cos\\lambda * \\cos2\\phi + \\sin2\\delta * \\sin\\lambda * \\sin2\\phi / 2    )\\\\\n    &M_{xz} = - M_0  (\\cos\\delta * \\cos\\lambda * \\cos\\phi  + \\cos2\\delta * \\sin\\lambda * \\sin\\phi         )\\\\\n    &M_{yy} = \\,\\,\\,\\, M_0  (\\sin\\delta * \\cos\\lambda * \\sin2\\phi - \\sin2\\delta * \\sin\\lambda * \\cos\\phi * \\cos\\phi )\\\\\n    &M_{yz} = - M_0  (\\cos\\delta * \\cos\\lambda * \\sin\\phi  - \\cos2\\delta * \\sin\\lambda * \\cos\\phi         )\\\\\n    &M_{zz} = \\,\\,\\,\\, M_0  (                         \\sin2\\delta * \\sin\\lambda                 )\n\\end{align}\n\nの関係にあります．加えて，O(r\\theta\\phi)の極座標系におけるモーメントテンソルは，この直交座標系におけるモーメントテンソルと，\\begin{pmatrix}\nM_{rr} & M_{r\\theta} & M_{r\\phi}\\\\\nM_{r\\theta} & M_{\\theta \\theta} & M_{\\theta \\phi}\\\\\nM_{r \\phi} & M_{\\theta \\phi} & M_{\\phi \\phi} \n\\end{pmatrix}\n= \n\\begin{pmatrix}\nM_{zz} & M_{xz} & -M_{yz} \\\\\nM_{xz} & M_{xx} & -M_{xy} \\\\\n-M_{yz} & M_{yx} & M_{yy}\n\\end{pmatrix}\n\nという関係があります (Aki and Richards, 2002, p. 113 Box 4.4)．これらを用いて，\n\nstrike, dip, rake から直交座標系のモーメントテンソルに変換\n\n1.の結果を断面に応じて座標変換\n\n2.の結果を極座標のモーメントテンソルに変換\n\nという3つのステップによって鉛直断面を投影できます．\n\nそれでは，実践してみましょう．上記1.と2.の手続きをそれぞれ関数化しておきます．\n\ndef sdr2moment(strike, dip, rake, M0): \n    \"\"\"calculate moment tensor component from strike, dip, and rake \"\"\"\n\n    sinδ  = np.sin(    np.deg2rad(dip   ))\n    cosδ  = np.cos(    np.deg2rad(dip   ))\n    sin2δ = np.sin(2 * np.deg2rad(dip   ))\n    cos2δ = np.cos(2 * np.deg2rad(dip   ))\n    sinλ  = np.sin(    np.deg2rad(rake  ))\n    cosλ  = np.cos(    np.deg2rad(rake  ))\n    sinφ  = np.sin(    np.deg2rad(strike))\n    cosφ  = np.cos(    np.deg2rad(strike))\n    sin2φ = np.sin(2 * np.deg2rad(strike))\n    cos2φ = np.cos(2 * np.deg2rad(strike))\n    \n    Mxx = - M0 * (sinδ * cosλ * sin2φ + sin2δ * sinλ * sinφ * sinφ )\n    Mxy =   M0 * (sinδ * cosλ * cos2φ + sin2δ * sinλ * sin2φ / 2    )\n    Mxz = - M0 * (cosδ * cosλ * cosφ  + cos2δ * sinλ * sinφ         )\n    Myy =   M0 * (sinδ * cosλ * sin2φ - sin2δ * sinλ * cosφ * cosφ )\n    Myz = - M0 * (cosδ * cosλ * sinφ  - cos2δ * sinλ * cosφ         )\n    Mzz =   M0 * (                         sin2δ * sinλ                 )\n\n    return Mxx, Myy, Mzz, Myz, Mxz, Mxy\n\n\ndef meca_crosssection(strike, dip, rake, Mw, orient='E'): \n\n    M0 = 10**( 1.5 * (Mw + 10.7) ) # in dyn-cm unit\n    exponent = int(np.floor(np.log10(M0)))\n    Mxx, Myy, Mzz, Myz, Mxz, Mxy = sdr2moment(strike, dip, rake, M0/10**exponent)\n\n    # Coordinate transform\n    if orient == 'E':\n        Mxx, Myy, Mzz, Myz, Mxz, Mxy = Mzz, Myy, Mxx, Mxy, -Mxz, -Myz\n    else: \n        Mxx, Myy, Mzz, Myz, Mxz, Mxy = Mxx, Mzz, Myy, -Myz, -Mxy, Mxz\n        \n    # Polar Coordinate\n    Mrr, Mtt, Mff, Mtf, Mrf, Mrt = Mzz, Mxx, Myy, -Mxy, -Myz, Mxz\n\n    # Data for plotting by pygmt.Figure.meca\n    spec = {\"mrr\": Mrr, \"mtt\": Mtt, \"mff\": Mff, \n            \"mrf\": Mrf, \"mrt\": Mrt, \"mtf\": Mtf, \n            \"exponent\": exponent}\n\n    return spec\n\nmeca の mt フォーマットでは，パラメタ exponent を使って 10^(exponent) を地震モーメントから M_0 から括りだしているということ，また地震モーメントは Nm ではなく dyn cm の単位系で表現している，ということに注意してください．\n\nそのうえで，先の bash スクリプトと同等の図を作成するには，以下のようにします．\n\nstrike = 180\ndip1 = 5\ndip2 = 80\ndip3 = 15\nrake1 = 30\nrake2 = 15\nrake3 = -80\n\nfig = pygmt.Figure()\n\nfig.basemap(projection = 'X10c/10c', region = [0, 4, 0, 4], \n            frame = ['WseN', 'xaf+lEasting', 'yaf+lNorthing'])\nfor lon, lat, dip, rake in zip([1, 2, 3], [3, 2, 1], \n                               [dip1, dip2, dip3], [rake1, rake2, rake3]):\n    fig.meca(spec={'strike':strike, 'dip':dip, 'rake': rake, 'magnitude': 5}, \n             longitude = lon, latitude = lat, depth = 1, scale = '2c', \n             compressionfill = 'blue', outline = 'default,black')\n    fig.text(justify='CB', x = lon, y = lat + 0.5, \n             text = f'({strike}, {dip}, {rake})', \n             font = '10p,Helvetica,Black')\n\nfig.text(justify='RT', x = 3.9, y = 3.9, \n         text = '(@~f@~, @~d@~, @~l@~)', font = '12p,Helvetica,Black')\n\nfig.shift_origin(0, -4.5)\n\n# E-Z cross section\nfig.basemap(projection = 'X10c/-4c', region = [0, 4, 0, 2], \n            frame = ['WSen', 'xaf+lEasting', 'ya1f0.2+lDepth'])\n\nfor lon, dip, rake in zip([1, 2, 3],  \n                          [dip1, dip2, dip3], [rake1, rake2, rake3]):\n\n    fig.meca(spec=meca_crosssection(strike, dip, rake, 5, orient='E'), \n             longitude = lon, latitude = 1, depth = 0, scale = '2c', \n             compressionfill = 'blue', outline = 'default,black')  \n\nfig.shift_origin(10.5, 4.5)\n\n# N-Z cross section\nfig.basemap(projection = 'X4c/10c', region = [0, 2, 0, 4], \n            frame = ['wSEn', 'xa1f0.2+lDepth', 'yaf+lNorthing'])\n\n\nfor lat, dip, rake in zip([3, 2, 1],  \n                          [dip1, dip2, dip3], [rake1, rake2, rake3]):\n\n    fig.meca(spec=meca_crosssection(strike, dip, rake, 5, orient='N'), \n             longitude = 1, latitude = lat, depth = 0, scale = '2c', \n             compressionfill = 'blue', outline = 'default,black')  \n\nfig.show()\n\n本家 gmt coupe とは異なり，自力でモーメントテンソルを座標変換しているので，その行列の定義を注意深く行えば，この例のように南北断面を横軸深さ，縦軸南北にすることも容易です．これを，strike 角だけを少しずつ変えながら \n\nこちらのページ で解説している方法で gifアニメーションにすると以下のようになります．\n\n\n\nWarning\n\n上記の例を作成している途上で，特定の(strike, dip, rake) の組み合わせをモーメントテンソルに変換してから meca で表示すると，表示されるメカニズム解の押し引きが反転してしまう，というバグに遭遇しました．この問題はモーメントテンソル対角成分のうち一つが0に十分近くなるときに起こりうる（いつでもとは限りません）ようです．strike, dip, rake の角度が整数値では，（90度とか270度などのキリの良い数字で）そういうことが発生しがちであるため，上記のアニメーションではこれらの角度値に対して描画結果に影響が出ないくらい小さな値（0.0001度）を加えて描画しています．\n\nこのバグについては\n\n報告 してあり，またGMT本家でも類似の \n\n報告 や，\n\nQ&Aでも似たような問題が挙げられているようです．","type":"content","url":"/mech#id-1","position":5},{"hierarchy":{"lvl1":"メッシュデータの扱い"},"type":"lvl1","url":"/mesh","position":0},{"hierarchy":{"lvl1":"メッシュデータの扱い"},"content":"z(x,y) のような形式で，x, yが等間隔のメッシュで与えられているデータを可視化してみます．\nここでは比較のためにmatplotlibも使います．\n\nimport pygmt\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n","type":"content","url":"/mesh","position":1},{"hierarchy":{"lvl1":"メッシュデータの扱い","lvl2":"等間隔メッシュデータ"},"type":"lvl2","url":"/mesh#id","position":2},{"hierarchy":{"lvl1":"メッシュデータの扱い","lvl2":"等間隔メッシュデータ"},"content":"\n\nまず，サンプルとして NumPy で適当な等間隔データを作成してみます．\n\nnx = 300\nny = 200\nx = np.linspace(0, 3, nx+1)\ny = np.linspace(0, 2, ny+1)\n\n長らくリスト zの i,j の順序が逆になっていました（等方的な図のうえ，XY方向のサイズも等しいため気が付きませんでした．お詫びします．(2025/02/25)\n\nz = np.zeros([ny+1,nx+1])\n\nfor i in range(nx):\n    for j in range(ny):\n        a = np.pi * ( x[i]    - np.sqrt(3.0) * y[j] )\n        b = np.pi * ( 3.*x[i] + np.sqrt(3.0) * y[j] )\n        z[j,i] = np.cos(2*a) * np.cos(4*b) + np.cos(5*a) * np.cos(3*b) + np.cos(7*a) * np.cos(b)\n\n試しにmatplotlibでプロットしてみると，以下のような感じです．\n\ng = plt.subplot()\ng.pcolormesh(x, y, z, shading='auto')\ng.set_aspect('equal')\n\nこのデータを pygmt の xyz2grd を用いて grdデータにしてプロットしてみます．\n\nNote\n\nxyz2grd はx, y, zそれぞれ1次元配列にしないと渡せないようです．そのため，np.meshgrid()と ravel() メソッドを通じて nx * ny サイズの1次元配列を作っています．\n\nもうすこしスッキリした書き方としては，x, y, zの代わりにそれらがパッキングされたdataリストを内包表記を用いて与える方法もあります:pygmt.xyz2grd(\n    data = [[x[i], y[j], z[i,j]] for i in range(len(x)) for j in range(len(y))]\n    # 他の要素は省略\n    )\n\nさらに発展的な方法として，xarray モジュールを用いて，以下のように表現することもできます．import xarray as xr\ngrddata = xr.DataArray(\n    data = z,\n    dims = [\"y\", \"x\"],\n    coords = {\"y\": y, \"x\": x}\n)\n\nこの方法は高速なだけでなく，PyGMTがグリッドデータのPython内部オブジェクトとしてxarrayを用いている点からもより直接的で好ましい方法と思われます．xyz2grdモジュールとことなり，わざわざxy方向のグリッド間隔を明示的に指定する必要がないのも好ましい点です．\n\nこのxarrayを用いる方法は染矢さんに\n\nご教示いただきました．記して感謝いたします．\n\nfig = pygmt.Figure()\n\nX, Y = np.meshgrid(x, y)\n\ngrddata = pygmt.xyz2grd(\n    region = [0, 3, 0, 2],     \n    spacing = '0.01/0.01', \n    x = X.ravel(),\n    y = Y.ravel(), \n    z = z.ravel()\n)\n\npygmt.makecpt(\n    cmap       = 'viridis',     # 比較のためカラーパレットはほとんど同じものを使う\n    series     = [-3, 3, 1], \n    continuous = True\n)\n\nfig.grdimage(\n    grid       = grddata, \n    projection = 'X9c/6c', \n    frame      = ['WSen', 'xaf+lx', 'yaf+ly'],    \n)\n\nfig.grdcontour(\n    grid     = grddata, \n    levels   = 1, \n    pen      = 'default,black'\n)\n\nfig.colorbar(\n    position = '+e'    \n)\n\nfig.show()\n\nここでは，grdimageのほかにgrdcontourも用いて等値線も描画してみました．使い方は上記の例を見ればほとんど明らかだと思います．\n\nNote\n\ngrdcontour で等値線の間隔を指定するオプションは，従来は intervals でしたが，v0.12.0 からは levels に変更されました．\n\n","type":"content","url":"/mesh#id","position":3},{"hierarchy":{"lvl1":"メッシュデータの扱い","lvl2":"2次元データの補間と可視化"},"type":"lvl2","url":"/mesh#id-2","position":4},{"hierarchy":{"lvl1":"メッシュデータの扱い","lvl2":"2次元データの補間と可視化"},"content":"続いて，粗いデータを補間しつつプロットしてみましょう．\n\nサンプルデータとして，Wikipediaの\n\n双3次補間の解説にある例を採用します．\n\nここからコードをお借りして（Creditはリンク先参照；CC-BY），以下のようなデータを使います．まずはデータ生成とmatplolibでの標準的可視化の例を示します．\n\nMETHODS = [ 'nearest', 'bilinear' ]\nCOLORS  = 'viridis'\n\nN = 5\nnp.random.seed(1)\ngrid = np.arange(0, N, 1)\ndata = np.round(np.random.rand(N, N), 1)\nmesh = np.meshgrid(grid, grid)\n\nfor interp in METHODS:\n\n    fig = plt.figure(figsize=(5,5))\n\n    ax = fig.add_axes([0.125, 0.175, 0.75, 0.75])\n    plt.imshow(data, interpolation=interp, cmap=COLORS, vmin=0, vmax=1)\n    plt.plot(mesh[0], mesh[1], marker='.', ms=8, color='k', lw=0)\n    plt.title(interp, weight='bold')\n    plt.xlim(grid.min()-0.5, grid.max()+0.5)\n    plt.ylim(grid.min()-0.5, grid.max()+0.5)\n    plt.xticks(grid)\n    plt.yticks(grid)\n\n    cax = fig.add_axes([0.125, 0.075, 0.75, 0.03])\n    cb = plt.colorbar(cax=cax, orientation='horizontal',\n                      ticks=np.linspace(0, 1, 6))\n    cb.solids.set_edgecolor('face')\n\nここで作られたデータを ravel()メソッド1次元化し，pygmt.surfaceで補間をしてみます．比較のため pygmt.xyz2grd で粗い間隔のままのプロットも作成します．\n\nfig = pygmt.Figure()\n\ngriddata_s = pygmt.surface(\n    x       = mesh[0].ravel(), \n    y       = mesh[1].ravel(), \n    z       = data.ravel(), \n    region  = [-0.5, 4.5, -0.5, 4.5], \n    spacing = '0.02/0.02',\n    tension = 0.5 # 無指定は0\n)\n\ngriddata_x = pygmt.xyz2grd(\n    x       = mesh[0].ravel(), \n    y       = mesh[1].ravel(), \n    z       = data.ravel(), \n    region  = [-0.5, 4.5, -0.5, 4.5], \n    spacing = '1/1',\n    registration = 'p'\n)\n\n\npygmt.makecpt(\n    cmap = 'viridis', \n    series = [0, 1, 0.1], \n    continuous = True\n)\n\nfig.grdimage(\n    grid = griddata_x, \n    projection = 'X10c/10c',\n    frame = ['WSen+tGMT xyz2grd', 'xaf', 'yaf'], \n)\n\nfig.plot(\n    x = mesh[0].ravel(), \n    y = mesh[1].ravel(), \n    style = 'c0.2c', \n    fill  = 'black', \n)\n\n# 右にずれる\nfig.shift_origin( xshift = 11 )\n\nfig.grdimage(\n    grid = griddata_s, \n    projection = 'X10c/10c',\n    frame = ['WSen+tGMT surface', 'xaf', 'yaf']    \n)\n\nfig.grdcontour( \n    grid = griddata_s, \n    pen = 'default,black', \n    annotation = '-'\n)\n\nfig.plot(\n    x = mesh[0].ravel(), \n    y = mesh[1].ravel(), \n    style = 'c0.2c', \n    fill  = 'black', \n)\n\nfig.colorbar(\n    position = '+e'    \n)\n\nfig.show()\n\nNote\n\npygmt.surface は tension factor t という量で補間の状況をコントロールします．その値を指定するオリジナルのGMTの -T オプションは，v0.8.0までが正式には実装されていませんでしたが， pygmt.surface{T = } とすると動作する状態でした．この T はオリジナルのGMTのsurfaceモジュールのオプション名です．\n\nv0.9.0から公式に pygmt.surface に GMTのTオプションに相当するtensionオプションが実装されたようです．\n\nsurfaceによる補間の挙動は，tensionパラメタによってだいぶ変わります．tensionを変えてみて，補間の違いを見てみましょう．\n\nfig = pygmt.Figure()\n\npygmt.makecpt(\n    cmap = 'viridis', \n    series = [0, 1, 0.1], \n    continuous = True\n)\n\ngriddata_s0 = pygmt.surface(\n    x       = mesh[0].ravel(), \n    y       = mesh[1].ravel(), \n    z       = data.ravel(), \n    region  = [-0.5, 4.5, -0.5, 4.5], \n    spacing = '0.02/0.02',\n    tension = 0.0 \n)\ngriddata_s1 = pygmt.surface(\n    x       = mesh[0].ravel(), \n    y       = mesh[1].ravel(), \n    z       = data.ravel(), \n    region  = [-0.5, 4.5, -0.5, 4.5], \n    spacing = '0.02/0.02',\n    tension = 0.5 \n)\ngriddata_s2 = pygmt.surface(\n    x       = mesh[0].ravel(), \n    y       = mesh[1].ravel(), \n    z       = data.ravel(), \n    region  = [-0.5, 4.5, -0.5, 4.5], \n    spacing = '0.02/0.02',\n    tension = 1.0 \n)\n\n\nfig.grdimage(\n    grid = griddata_s0, \n    projection = 'X10c/10c',\n    frame = ['WSen+ttension = 0.0', 'xaf', 'yaf']    \n)\n\nfig.grdcontour( \n    grid = griddata_s0, \n    pen = 'default,black', \n    annotation = '-'\n)\n\nfig.plot(\n    x = mesh[0].ravel(), \n    y = mesh[1].ravel(), \n    style = 'c0.2c', \n    fill  = 'black', \n)\n\n# 右にずれる\nfig.shift_origin( xshift = 11 )\n\nfig.grdimage(\n    grid = griddata_s1, \n    projection = 'X10c/10c',\n    frame = ['WSen+ttension = 0.5', 'xaf', 'yaf']    \n)\n\nfig.grdcontour( \n    grid = griddata_s1, \n    pen = 'default,black', \n    annotation = '-'\n)\n\nfig.plot(\n    x = mesh[0].ravel(), \n    y = mesh[1].ravel(), \n    style = 'c0.2c', \n    fill  = 'black', \n)\n\nfig.colorbar(\n    position = '+e'    \n)\n\n# 右にずれる\nfig.shift_origin( xshift = 11 )\n\n\nfig.grdimage(\n    grid = griddata_s2, \n    projection = 'X10c/10c',\n    frame = ['WSen+ttension = 1.0', 'xaf', 'yaf']    \n)\n\nfig.grdcontour( \n    grid = griddata_s2, \n    pen = 'default,black', \n    annotation = '-'\n)\n\nfig.plot(\n    x = mesh[0].ravel(), \n    y = mesh[1].ravel(), \n    style = 'c0.2c', \n    fill  = 'black', \n)\n\nfig.show()","type":"content","url":"/mesh#id-2","position":5},{"hierarchy":{"lvl1":"Obspyとの連携"},"type":"lvl1","url":"/obspy","position":0},{"hierarchy":{"lvl1":"Obspyとの連携"},"content":"ObsPyは地震学で広く使われているパッケージです．様々な機能がありますが，広範な種類の波形フォーマットに対応しているため，自作のプログラムでも波形の読み書き部分だけはObsPyで，といった使い方ができます．ここではこの機能を使って地震波形ファイルを読み込み，それをPyGMTで描画してみます．\n\nimport pygmt\nimport obspy\nfrom obspy import UTCDateTime\n\nSAC (Seismic Analysis Code) に含まれている地震波形例をファイルとして保存し，それをObsPyから読み込んでみ ましょう．SACでは以下のようなコマンドを実行することでサンプルファイルを作ります．$ sac\n SEISMIC ANALYSIS CODE [10/13/2020 (Version 101.6a)]\n Copyright 1995 Regents of the University of California\n\nSAC> funcgen seismogram\nSAC> w dat/example.sac\nSAC> quit\n\nObsPy で読み込むには obspy.core.read を使います．このコマンドは任意個数の地震波形を stream 形式という専用の型のリストに読み込みます．今回読み込むのは1波形だけなので，その最初の成分を trace0 として抽出しましょう．\n\ntrace = obspy.core.read('./dat/example.sac')\ntrace0 = trace[0]\n\nObsPyは内部でmatplotlibと連携していて，波形に付随するメソッドの plot を使うだけで，波形を適当にプロットしてくれます．\n\np = trace0.plot()\n\nObsPyで読み込んだ波形には，\n\n波形振幅データ trace0.data\n\n波形時刻情報 trace0.times()\n\nその他ヘッダ情報 trace0.stats\n\nといった情報が含まれます．ObsPyは様々な波形データ形式に対応するなかで，今回はSAC形式の波形を読み込んでいるので，trace0.stats.sacという辞書に，SAC形式のヘッダが格納されています．\n\nでは，これを PyGMT で同じようにプロットしてみましょう．\n\nfig = pygmt.Figure()\n\nfig.plot(\n    projection = 'X20c/5c',\n    region = [trace0.stats.starttime, trace0.stats.endtime, -2, 2],\n    x = trace0.times(\"timestamp\"), \n    y = trace0.data,\n    pen = 'thick,50/50/150'\n)\n\nfig.text(\n    text = \"Station \" + trace0.stats.station, \n    position = 'RT', \n    offset = 'j0.5c/0.5c',\n    font = '12p,Helvetica-Bold,Black'\n)\n\nfig.basemap(\n    frame  = ['WSen', 'xaf+ltime', 'yaf+lampltude' ],\n)\n\nfig.show()\n\n基本的にこれまでに出てきたコマンドの組み合わせで実現できます．\n\n特記すべきはregion の横軸で，ObsPyのヘッダ（stats）に含まれる開始時間 starttime と 終了時間 endtime がそのまま pygmt の範囲指定に使えるのです．また，fig.plot に与える x軸データも，ObsPyの波形の時間情報 trace0.times() をそのまま与えることができます．\n\nfig = pygmt.Figure()\n\nfig.plot(\n    projection = 'X20c/5c',\n    region = [0, trace0.stats.delta * trace0.stats.npts, -2, 2],\n    x = trace0.times(), \n    y = trace0.data,\n    pen = 'thick,50/50/150'\n)\n\nfig.text(\n    text = \"Station \" + trace0.stats.station, \n    position = 'RT', \n    offset = 'j0.5c/0.5c',\n    font = '12p,Helvetica-Bold,Black'\n)\n\nfig.basemap(\n    frame  = ['WSen', 'xaf+ltime [s]', 'yaf+lampltude' ],\n)\n\nfig.show()","type":"content","url":"/obspy","position":1},{"hierarchy":{"lvl1":"PyGMT-HOWTO"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"PyGMT-HOWTO"},"content":"","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"PyGMT-HOWTO","lvl2":"このWebサイトについて"},"type":"lvl2","url":"/#id-web","position":2},{"hierarchy":{"lvl1":"PyGMT-HOWTO","lvl2":"このWebサイトについて"},"content":"本Webサイトは，美麗な地図やグラフを作成できるツール\n\nGeneric Mapping Tools (GMT)のPython インターフェースである\n\nPyGMTの地震学における利用を主な対象としたチュートリアルです．","type":"content","url":"/#id-web","position":3},{"hierarchy":{"lvl1":"PyGMT-HOWTO","lvl2":"GMTとPyGMT"},"type":"lvl2","url":"/#gmt-pygmt","position":4},{"hierarchy":{"lvl1":"PyGMT-HOWTO","lvl2":"GMTとPyGMT"},"content":"現在のPyGMTやGMTでどのような図が作成できるかを知るには，公式のギャラリーを見てみるのが良いでしょう．\n\nGMT Example Gallery\n\nPyGMT Gallery\n\nもともと，GMTはUn*x用のコマンドラインツール群として開発されました．単独Postscriptという形式の画像データを生成する多数のコマンド群からなり，シェルスクリプト等によりそれらのコマンドを組み合わせる必要がありました．シェルスクリプトの特性上，どうしても可視化のコードが煩雑になりがちで，再利用性も低くなりがちでした．\n\nPyGMTは，そんなGMTのPythonインターフェースです．Python上のデータから（原則としては中間ファイルやシェルスクリプトを介することなく）直接GMTによる可視化を行うことができます．さらに\n\nNumPyや\n\npandasといったPython上の科学技術計算でよく使われるライブラリのデータ型と互換性があるため，研究成果の可視化ツールとしてとても使いやすいと思います．\n\nPython上の可視化というと，通常のグラフでは\n\nmatplotlibが，地図では\n\ncartopyが広く使われているようです．PyGMTとどちらを使うかは好みの問題だと思いますが，筆者の意見ではPyGMTのほうが美麗なグラフを生成しやすいと思います．また，GMTの地図投影やグリッドデータ（2次元等間隔のメッシュに対して値が割り当てられたデータ）を扱う機能の豊富さは，大変魅力的です．一方，可視化のための処理速度はやや遅めのようです．特に地震学分野ではこれまでGMTが広く使われていたという経緯もあるため，これまでと同じようなやり方で可視化ができるという継続性に魅力を感じる人もいるかもしれません．","type":"content","url":"/#gmt-pygmt","position":5},{"hierarchy":{"lvl1":"PyGMT-HOWTO","lvl2":"このページの目指すもの・目指さないもの"},"type":"lvl2","url":"/#id","position":6},{"hierarchy":{"lvl1":"PyGMT-HOWTO","lvl2":"このページの目指すもの・目指さないもの"},"content":"本Webサイトでは，基本的な地図の作り方から震源分布や地震波形など，特に地震学周辺分野における応用を意図した作図を取り扱います．また，地震学解析で広く使われているライブラリである\n\nObsPyとの連携も紹介します．可視化は\n\nJupyter Notebook上で行うことを前提としますが，紹介するスクリプトはほとんどそのままPythonスクリプトとして動作します．\n\n2025年現在，PyGMTはいまだ活発な開発が続けられていますが，GMTのあらゆる機能がPythonで使えて，かつそれがドキュメント化されているとまでは言い切れない状態にあります．そこで，（ごく一部ではありますが）公式にはドキュメント化されてないものの，筆者が試行錯誤的に見つけた使い方のTipsなども，紹介します．\n\n一方，本Webサイトはマニュアルではありませんので，PyGMTやGMTのあらゆる機能を網羅することは目標としていません．また，Un*xコマンドラインの利用についてはある程度知っていることを前提としています．\n\n本WebサイトのコードはmacOS25 TahoeとUbuntu 22.04 LTSのマシン上でMiniforgeによって\n\n構築したJupyter Notebookにより動作確認しています．PyGMTの開発にともない，昔は通用した書き方でも最新版では警告がでたり，あるいはエラーになることがあります．本サイトのコードは，更新時点での最新の公式リリースで動作確認をしています．（以下の改版履歴をご覧ください）\n\n本ページを見てなにか間違いを見つけたり，あるいは「もっと良い書き方がある」と思われたら，ぜひ\n\ngithubのIssuesでご教示ください．本ページ上部のGitHubのアイコンからもたどれます．","type":"content","url":"/#id","position":7},{"hierarchy":{"lvl1":"PyGMT-HOWTO","lvl2":"おもな改版履歴"},"type":"lvl2","url":"/#id-1","position":8},{"hierarchy":{"lvl1":"PyGMT-HOWTO","lvl2":"おもな改版履歴"},"content":"日付\n\n内容\n\n2025-11-29\n\nPyGMT Version 0.17.0 に対応．\n\n軸の設定の解説を追加．HTMLビルドエンジンの更新．\n\n2025-08-24\n\nPyGMT Version 0.16.0 に対応．日本語フォントの解説 (8/31微細修正)\n\n2024-12-14\n\nGoogle Colab 上における活用について記述\n\n2024-12-13\n\nPyGMT Version 0.13.0 に対応．メカニズム解断面図の説明追加\n\n2024-06-21\n\nAnacondaラインセンス変更にともなうインストール方法の修正\n\n2023-07-21\n\nPyGMT Version 0.12.0 に対応\n\n2023-07-05\n\nアニメーション動画の作成ページを作成\n\n2023-06-07\n\nPyGMT Version 0.9.0 に対応，画像保存についてのページ作成\n\n2022-06-28\n\n内容のさらなる分割，xyデータプロットの説明追加．\n\n2022-06-17\n\n地形断彩図の分割と説明の追加\n\n2022-06-17\n\n内容を複数ページに分割開始．前書きとインストール解説の詳細化\n\n2021-12-20\n\n初版公開","type":"content","url":"/#id-1","position":9},{"hierarchy":{"lvl1":"画像の保存"},"type":"lvl1","url":"/savefig","position":0},{"hierarchy":{"lvl1":"画像の保存"},"content":"以下の例を考えましょう．\n\nimport pygmt\n\nfig = pygmt.Figure()\n\nfig.coast(\n    projection  = 'N138/12c',                         \n    region      = (128, 146, 30, 46),                 \n    shorelines  = 'default,black',                    \n    area_thresh = 100,                                \n    resolution  = 'f',                                \n    land        = '249/243/202',                      \n    water       = '190/220/250',                      \n    map_scale   = '142.5/32/32/400',                  \n    frame       = ['WSen+tFigure', 'xafg', 'yafg']  \n)\n\n\n","type":"content","url":"/savefig","position":1},{"hierarchy":{"lvl1":"画像の保存","lvl2":"savefig メソッド"},"type":"lvl2","url":"/savefig#savefig","position":2},{"hierarchy":{"lvl1":"画像の保存","lvl2":"savefig メソッド"},"content":"\n\nPyGMTの基本 で紹介したように，もっとも簡単に画像を保存するには，以下のように savefig メソッドを用います．\n\nfig.savefig('fig/map-by-savefig.png')\n\nこのように出力した画像をそのまま表示したのが以下です．showメソッドで表示したものとほぼかわりません．\n\nファイル種別はファイル名の拡張子で自動的に判断されます．上記のpngのほか，画像としてはpdf, jpg, bmp, tif, epsが使えます．たとえば以下のようにするとPDFで保存できます．\n\nfig.savefig('fig/map-by-savefig.pdf')\n\nsavefigメソッドは，デフォルトでは画像の描画範囲ギリギリまで余白を切り落とします．場合によっては，描画された最外部がわずかに切り落とされてしまうこともあるようです．以下のようにcropオプションをつけることで，この問題を回避できます．\nここではその効果をはっきり確認するため，あえて大きめの余白をとってみましょう．\n\nfig.savefig('fig/map-by-savefig-crop.png', crop='5c')\n\n\n\nたしかに周りに余白が作られていることがわかります．\n\nDanger\n\nsavefigメソッドの\n\nマニュアルには，cropオプションはBool（True or False）をとる，と書いてあります．\nところが，crop=Falseを指定してみたところ，筆者の環境では処理が終わらなくなってしまいました．上記の例のように，マニュアルに記載がないものの，文字列として余白の大きさをcm単位で指定することで正常に処理されました．\n\nまた，出力がpng, jpg, tif形式のときは，デフォルトで anti_alias=True が仮定されており，画像化するときにアンチエイリアス処理がおこなわれます．アンチエイリアス処理の有無で劇的な変化はないようですが，文字のエッジ部分はやや綺麗になるようです．\n\nそのほか，dpiオプションに数値を渡すと，画像の解像度を指定できます．デフォルト値はかなり高めです．\n\n","type":"content","url":"/savefig#savefig","position":3},{"hierarchy":{"lvl1":"画像の保存","lvl3":"KML出力","lvl2":"savefig メソッド"},"type":"lvl3","url":"/savefig#kml","position":4},{"hierarchy":{"lvl1":"画像の保存","lvl3":"KML出力","lvl2":"savefig メソッド"},"content":"\n\n面白いところではGoogle Earthなどで表示可能な kml フォーマットが選べます．ただし，\n\n投影法（projection）はXで，かつ大きさは角度単位（d）で指定すべき\n\nsavefig の出力ファイル名にディレクトリを含むとうまくいかない\n\nframe を描画すると位置がズレる\n\nという制限があるようです．そこで，上記のスクリプトをKML用に変更してみると，以下のようになります．\n\nfig_kml = pygmt.Figure()\n\nfig_kml.coast(\n    projection  = 'X18d/16d',         \n    region      = (128, 146, 30, 46), \n    shorelines  = 'default,black',    \n    area_thresh = 100,                \n    resolution  = 'f',                \n    land        = '249/243/202',      \n    water       = '190/220/250',      \n    map_scale   = '142.5/32/32/400'   \n)\n\nfig_kml.savefig('map.kml')\n\nこうしてできたKMLファイルをGoogle Earthで表示したものが以下のスクリーンショットです．ただし，Google Earthの地形が背景に透けて見えるよう，同アプリ上で透過処理を行いました．\n\nたしかに，PyGMTで作成した海岸線とGoogle Earthの海岸線がよく一致していることが確かめられます．\n\ncoastで地図を描いただけのものをGoogle Earthで表示してもあまり意味はありませんが，地図上のデータプロットがインタラクティブに操作できる地図アプリ上に表示できるのは有用かもしれません．\n\n","type":"content","url":"/savefig#kml","position":5},{"hierarchy":{"lvl1":"画像の保存","lvl2":"psconvertメソッド"},"type":"lvl2","url":"/savefig#psconvert","position":6},{"hierarchy":{"lvl1":"画像の保存","lvl2":"psconvertメソッド"},"content":"\n\nsavefigよりももう少し細かい制御ができるのが psconvert メソッドです．これまで savefigで指定してきたオプションとほぼ互換なオプションは以下の通りです．下記にある調整は基本的に savefig メソッドで実現できます．\n\nfig.psconvert(crop='0.5c',                   # 切り落とし\n              dpi=300,                       # 解像度（PDFは不要）\n              fmt='g',                       # g: png, f: pdf\n              prefix='fig/map-by-psconvert', # 拡張子の手前までの名前\n              anti_aliasing=['g4', 't4']     # これが一番強いアンチエイリアス\n)","type":"content","url":"/savefig#psconvert","position":7},{"hierarchy":{"lvl1":"時系列の扱い"},"type":"lvl1","url":"/timeseries","position":0},{"hierarchy":{"lvl1":"時系列の扱い"},"content":"import pygmt\nimport datetime\n\n震源分布に用いたデータから，地震発生日とマグにチュードからなる M-T 図を作成してみましょう．まずはdatetimeモジュールを用いて，震源カタログの年・月・日のデータをまとめて日付オブジェクトのリストにします．\n\n# 昔のバージョンは pygmt.datasets.load_japan_quakes() でした\nhypdata = pygmt.datasets.load_sample_data(name='japan_quakes')\nhyptim = [datetime.datetime(yr, mo, dy) for yr, mo, dy in zip(hypdata.year, hypdata.month, hypdata.day)]\nhypmag = hypdata.magnitude\n\nここではリストhyptimを生成するのにPythonの内包表記を活用しています．この表現は，愚直に書くとhyptim = []\nfor yr, mo, dy in zip(hypdata.year, hypdata.month, hypdata.day):\n    hyptim.append(datetime.datetime(yr, mo, dy))\n\nと等価です．\n\nまた，for文に現れる zip 関数は複数のリスト（など）の要素をまとめる関数で，ループで変数 yr, mo, dy にそれぞれ hypdata.year，hypdata.month, hypdata.day から一つずつの要素を代入してくれます．．\n\nfig = pygmt.Figure()\n\nfig.basemap(\n    projection = 'X15c/5c', \n    region     = ['1987-01-01', '1987-12-31', 0, 8], \n    frame      = ['WS', 'pxa1o', 'sxa1Y+lYear/Month', 'yaf+lMagnitude']\n)\n\nfor dy, mag in zip(hyptim, hypmag):\n    \n    fig.plot(\n        x    = [dy, dy],\n        y    = [0, mag],\n        pen  = 'default,black'\n    )\n    \n\nfig.plot(\n    x     = hyptim, \n    y     = hypmag, \n    style = 'c0.2c', \n    fill  = '100/100/255@30', \n    pen   = 'default,black'\n)\n\nfig.show()\n\nまず fig.basemap で枠を描画しています．領域の横軸は YYYY-MM-DD の日付ISOフォーマットで指定しています．frame については，横軸は軸のすぐそば（primary）に月名（o）を，少し離れて（secondary）年（Y）を描画しています．このように二種類の軸情報を描画するには，px (primary) と sx (secondary) をそれぞれ指定すればよいです．\n\n次のforループでは，準備してあった datetime 型の日付とマグニチュードからzip関数を用いてそれぞれ一つづつ抜き出し，縦棒を描画しています．シェルスクリプトの場合は，区切り行（デフォルトは > が1文字目にある行）を用いて> \n1987-01-01 0\n1987-01-01 5\n>\n1987-02-05 0\n1987-02-05 4.5\n>\n...\n\nのようなマルチセグメントデータを作って一斉にプロットできます．\nしかし，PyGMTにおいて変数受け渡しでマルチセグメントデータをfig.plotに渡す方法が今のところ不明です．\nそこで，for 分で地震の個数回 plot 命令を発行するという力技で解決しています．効率の良い方法とはいえず，一旦ファイルに落としてから読み込むほうが素直かもしれません．","type":"content","url":"/timeseries","position":1},{"hierarchy":{"lvl1":"地形段彩図の描画"},"type":"lvl1","url":"/topo-map","position":0},{"hierarchy":{"lvl1":"地形段彩図の描画"},"content":"GMTは(x, y, z) あるいは (lon, lat, z) のような3次元データとしてNetCDF形式のデータ（通称グリッドデータ）を読むことができ，z軸の値に応じて色を割り当てることができます．ここでは特に地図としてよく用いられる地形段彩図の描画とその応用を扱います．\n\nまずはpygmtモジュールを読み込んでおきましょう．\n\nimport pygmt\n\nGMTでは手持ちのNetCDF（grd or nc）ファイルを描画するのはもちろん，GMT6以降ではネットワーク越しにグローバルな地形データを取得するコマンドが提供されています．そこで，ここではその pygmt 版を用いて，地形図の描画を行ってましょう．\n\n地形データを読み込むには以下のようにします．\n\ngrid_data = pygmt.datasets.load_earth_relief(\n    resolution='01m',\n    region = [128, 150, 28, 50]\n)\n\n上記のコマンドで，region で指定した地域の地形を resolution の解像度で読み込み，左辺の変数（grid_data）に格納します．この変数を用いてあとで地形図を作成します．\n\nregionの指定方法は地図と同じです．省略した場合には全世界のグローバルデータが読み込まれます．\n\nresolutionは 01d, 30m, 20m, 15m, 10m, 06m, 05m, 04m, 03m, 02m, 01m, 30s, 15s, 03s, 01s から，つまり1秒角から1度までのうちからどれか一つを選びます．\n\nダウンロードされるデータはSRTM（Shuttle Rader Topography Mission）で，解像度によりデータソース（提供年）が異なるようです．また，1秒と3秒グリッドには海底地形データが存在しないため，15秒データから補間されます．ダウンロードしたデータは ~/.gmt/ 以下にキャッシュされます．あまり細かいグリッドで広域のデータを読み込むと，ダウンロードにもプロットにも時間がかかりますし，ディスクスペースも消費しますので，注意してください．\n\nまずはこの地形図をほとんどそのまま可視化してみましょう．\n\nfig = pygmt.Figure()\n\n# カラーマップ作成．以降ではこのCPTが自動的に使われる．\npygmt.makecpt(\n    cmap = 'geo', \n)\n\n# 標高と斜度データを可視化\nfig.grdimage(\n    projection = 'N138/12c', \n    region     = [128, 146, 30, 46], \n    grid       = grid_data,             # さきほど作成したデータを変数として渡す\n    frame      = ['WSen', 'xaf', 'yaf']\n)\n\nfig.show()\n\nこれで色が付きました．海岸線を描画した代わりに fig.grdimage でさきほど作成した grid_data の値に応じて色を割り当てています．その値と色の対応テーブルを作成するのが pygmt.makecpt コマンドです．このコマンドではカラーマップのほか，値の範囲なども指定できます．ここでは，geoというカラーマップだけを指定し，値の範囲は省略してデフォルトの状態に任せています．\n\nカラーマップの種類は\n\nGMTのcookbookに記載されています．とても種類が多いですが，地形の描画に向いているのはearth, geo, etopo1, globe, relief, terra, worldあたりです．ただし，このうちterraとworldはデフォルトのカラーパレットの範囲が日本海溝の最も深い部分をうまく表現できないようで，範囲の調整が必要になりそうです．\n\nTip\n\nGMTでは，cptファイルや地形のグリッドデータは，一旦ファイルに保存し，そのファイル名を gmt grdimage のオプションとして指定していました．それがPyGMTではグリッドデータについては変数で，cptファイルについては直前に生成したものが自動で，それぞれ読み込まれます．\n\nこれは単純な作図では記述量が減って便利ですが，特に複数のcptファイルを使う複雑な絵ではかえってやっかいかもしれません．ですが，引数cmapにはあらかじめ作成しておいたcptファイルの名前を指定することでも実行可能です．gridについても同様で，Python以外の環境で作成した既存のNetCDFファイル名を指定してそれを直接読み込み，可視化することができます．\n\n","type":"content","url":"/topo-map","position":1},{"hierarchy":{"lvl1":"地形段彩図の描画","lvl2":"より凝った段彩図の描画"},"type":"lvl2","url":"/topo-map#id","position":2},{"hierarchy":{"lvl1":"地形段彩図の描画","lvl2":"より凝った段彩図の描画"},"content":"\n\n段彩図をより見栄え良くするには，grdgradientによる傾斜データの作成と利用が有効です．\n\ngradient_data = pygmt.grdgradient(\n    grid      = grid_data,\n    azimuth   = [45, 135], \n    normalize = 'e0.7'\n)\n\nGMTの grdgradient と同じですが，地形の可視化に用いる場合には方角 azimuth を複数方向の組み合わせにし，かつ normalize を上記の例程度の値にしておくのが良いようです．\n\nToDo\n\nDemoを見ると，radianceパラメータにより計算したgrdデータで地形可視化を行っている．要調査．\n\nfig = pygmt.Figure()\n\n# カラーマップ作成．以降ではこのCPTが自動的に使われる．\npygmt.makecpt(\n    cmap = 'geo', \n)\n\n# 標高と斜度データを可視化\nfig.grdimage(\n    projection = 'N138/12c', \n    region     = [128, 146, 30, 46], \n    grid       = grid_data, \n    shading    = gradient_data\n)\n\n# 海岸線描画と海域を半透明シェーディング\nfig.coast(\n    area_thresh = '100', \n    water       = 'black@80',\n)\n\n# 距離スケールの背景のための領域\nfig.plot(\n    data = [[139, 31], [145,31], [145,32.5], [139,32.5]], \n    fill = 'white',\n    transparency = 20,\n    straight_line = True    \n)\n\n# もう一度海岸線\nfig.coast(\n    area_thresh = '100', \n    map_scale   = '142/32/32/500',\n    shorelines  = 'faint,black',\n    frame       = ['WSen', 'xaf', 'yaf']\n)\nfig.show()\n\nここでは，見た目を向上させるテクニックを2つほど使っています．どちらもPyGMT以外の話題も含みますが，すこし詳しく解説しておきましょう．\n\nまず，単に fig.grdimage で色を塗るだけでなく，その上に海岸線を描画しています．さらに，この例で用いた earth カラーパレットは陸域と海域の差が目立たなかったため，fig.coast の water で透明度80%の黒色（black@80）で海域を塗りつぶすことで，相対的に陸域が浮かび上がって見えるように工夫しています．色名のあとの@は透明度指定で，100に近いほど透明度が高くなります．water = 'black@80 の行をコメントアウトして実行してみると，その差が実感できるでしょう．ただし，このテクニックを使うともとの色を改変することになりますので，カラースケールを表示してもその色が正確ではなくなりますので，注意が必要です．\n\n一方，地図の距離スケール（fig.pscoastのmap-scaleオプション）をカラフルなカラーマップ上に描画すると，視認性がとても低くなってしまいます．そこで，fig.plot() で四角形の頂点を与え，半透明の白い「箱」を先に描画しています．これは順番が大事で，fig.coast()の前に予め箱を描画しておかないと，せっかくの地図スケールを塗りつぶしてしまうことになりかねません．fig.plot() には四隅の頂点を2次元配列として data= オプションに与えていますが，x軸とy軸の1次元配列を個別に x = , y =  として与えることもできます．なお，地図上に頂点を指定してポリゴンを描画すると，デフォルトではその辺が地図上の大円経路に沿った線として描画されます．結果として，地図投影上は曲がった線に見えてしまいます．これを避けているのが straight_line = True オプションです．\n\nImportant\n\nfig.plot()のオプション fill= はその名のとおり塗りつぶしの色を指定するオプションですが，PyGMT v0.8.0 までは，このオプションは color= であったものが，オプション名の変更がなされたようです．しばらくの移行期間を経て，v0.12.0 以降ではcolorオプションは動作しなくなりました．","type":"content","url":"/topo-map#id","position":3},{"hierarchy":{"lvl1":"xyグラフの描画"},"type":"lvl1","url":"/xy","position":0},{"hierarchy":{"lvl1":"xyグラフの描画"},"content":"PyGMTは本家GMTと同じく，投影法（projection）に X を選ぶことで，直交座標系のXYグラフを作成することができます．\n\nここでは，データ作成や比較のためにNumPyとmatplotlibも使います．\n\nimport pygmt\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n","type":"content","url":"/xy","position":1},{"hierarchy":{"lvl1":"xyグラフの描画","lvl2":"関数グラフ"},"type":"lvl2","url":"/xy#id","position":2},{"hierarchy":{"lvl1":"xyグラフの描画","lvl2":"関数グラフ"},"content":"\n\nまずはデータを作成してみましょう．\n\nx = np.arange(0, 4*np.pi, np.pi/50)\ny = np.sin(x)\n\nfig.plotでpenを指定すると曲線が描画できます．\n\nfig = pygmt.Figure()\n\nfig.plot(region = [0, 4*np.pi, -1.1, 1.1], \n         projection = 'X10c/5c', \n         x = x, y = y, \n         pen = 'thick,black', \n         frame = ['WS', 'xaf+lx', 'yaf+ly'])\n\nfig.show()\n\nplotを重ねていくことで様々なグラフを重ね描きできます：\n\nfig = pygmt.Figure()\n\nfig.basemap(region = [0, 4*np.pi, -1.1, 1.1], \n            projection = 'X10c/5c', \n            frame = ['WS', 'xaf+lx', 'yaf+ly'])\nfig.plot(x = x, y = np.sin(x), pen = 'thick,200/100/100', label=\"sin(x)\")\nfig.plot(x = x, y = np.cos(x), pen = 'thick,100/100/200', label=\"cos(x)\")\nfig.legend()\nfig.show()\n\nここでは，fig.legend() を用いて凡例を表示しました．plotなどでlabelオプションにより名前をつけておけば，legend()は引数なしで自動的に右上に凡例を表示してくれます．位置や表現を調整したいときには\n\nマニュアルを参考にオプションを追加するのが良いでしょう．\n\n","type":"content","url":"/xy#id","position":3},{"hierarchy":{"lvl1":"xyグラフの描画","lvl2":"シンボルのプロット"},"type":"lvl2","url":"/xy#id-1","position":4},{"hierarchy":{"lvl1":"xyグラフの描画","lvl2":"シンボルのプロット"},"content":"\n\nplot()に style オプションを追加することで，シンボルや（固定サイズの場合は）サイズの指定を行います．style指定がないと，plotはデータとして与えられた点をつないだ線を描画します．\n\nシンボルは\n\nGMT公式ドキュメントの以下の図の通りです：\n\n\nx y 座標を乱数（np.random.rand）によって生成してプロットを行ってみましょう：\n\nn = 50\n\nfig = pygmt.Figure()\n\n# シンボルの種類と色\nsymb = ['c',   'a',    'i',      't',      's',         'd']    \ncol  = ['red', 'blue', 'purple', 'orange', 'darkgreen', 'pink']\nname = ['circle', 'star', 'inv. triangle', 'triangle', 'square', 'diamond']\n\nfig.basemap(\n    projection = 'X10c/10c', \n    region     = [0, 5, 0, 5], \n    frame      = ['WS+trandomly distributed symbols', 'xaf', 'yaf']\n)\n\nfor i in range(len(symb)):\n    \n    dat = 5 * np.random.rand(n,n)\n\n    fig.plot(\n        data  = dat, \n        style = symb[i] + '0.4c', \n        fill  = col[i] + '@70',\n        pen   = 'default,black', \n        label = name[i]\n    )\n\nfig.legend(transparency=20)\n\nfig.show()","type":"content","url":"/xy#id-1","position":5}]}